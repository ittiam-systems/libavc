/******************************************************************************
 *
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *****************************************************************************
 * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
/**
 *******************************************************************************
 * @file
 *  isvcd_mode_mv_resamp.c
 *
 * @brief
 *  Contains routines that resample for SVC resampling
 *
 * @author
 *  Kishore
 *
 * @par List of Functions:
 *  - isvcd_ref_lyr_part_idc()
 *  - isvcd_check_motion()
 *  - isvcd_get_min_positive()
 *  - isvcd_motion_scale_crop_wdw_change()
 *  - isvcd_interlyr_motion_scale()
 *  - isvcd_store_motion_map()
 *  - isvcd_check_mv_diff()
 *  - isvcd_interlyr_motion_submbmode_pred()
 *  - isvcd_interlyr_mbmode_pred_bmb()
 *  - isvcd_populate_ref_idx()
 *  - isvcd_interlyr_mbmode_pred()
 *  - isvcd_compute_interlyr_motion_mode()
 *  - isvcd_interlyr_motion_mode_pred_dyadic()
 *  - isvcd_compute_scaled_offsets()
 *  - isvcd_comp_mode_mv_res_init()
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */

#include <assert.h>
#include <string.h>
#include "ih264_typedefs.h"
#include "ih264_macros.h"
#include "ih264_platform_macros.h"
#include "ih264_defs.h"
#include "ih264d_bitstrm.h"
#include "ih264d_defs.h"
#include "ih264d_debug.h"
#include "isvcd_structs.h"
#include "ih264d_defs.h"
#include "ih264d_parse_cavlc.h"
#include "ih264d_mb_utils.h"
#include "ih264d_deblocking.h"
#include "ih264d_dpb_manager.h"
#include "ih264d_mvpred.h"
#include "ih264d_inter_pred.h"
#include "ih264d_process_pslice.h"
#include "ih264d_error_handler.h"
#include "ih264d_cabac.h"
#include "ih264d_debug.h"
#include "ih264d_tables.h"
#include "ih264d_parse_slice.h"
#include "ih264d_utils.h"
#include "ih264d_parse_islice.h"
#include "ih264d_process_bslice.h"
#include "ih264d_process_intra_mb.h"
#include "isvcd_mode_mv_resamp.h"
#include "ih264_debug.h"

const WORD32 g_i4_dpb_size[16] = {
    396,  396,   900,   2376,  2376,  2376,  4752,   8100,
    8100, 18000, 20480, 32768, 32768, 34816, 110400, 184320,
};

/*****************************************************************************/
/* total_coeff and trailing 1's decode table                                 */
/*****************************************************************************/

/*-----------------------------------------------------------------------*/
/* This table consists of info about the NNZ and t1 table                */
/*-----------------------------------------------------------------------*/

const UWORD16 g_au2_nnz_tbl_offsets[9] = {0, 0, 120, 120, 224, 224, 224, 224, 224};

/*-----------------------------------------------------------------------*/
/* For given bits in the bitstream, this table consists of 3 parts       */
/* | tcoeff(4) | t1s(2) | suffix(2)|                                     */
/*-----------------------------------------------------------------------*/

const UWORD8 g_au1_codegx_avc[312] = {
    0,   0,   0,   0,   0,   0,   0,   0,   4,   4,   4,   4,   4,   4,   4,   4,   24,  24,
    24,  24,  24,  24,  24,  24,  22,  22,  2,   2,   45,  45,  45,  45,  78,  78,  42,  42,
    61,  61,  61,  61,  94,  94,  58,  58,  38,  38,  18,  18,  110, 110, 74,  74,  54,  54,
    34,  34,  126, 126, 90,  90,  70,  70,  50,  50,  142, 142, 106, 106, 86,  86,  66,  66,
    115, 139, 119, 99,  159, 123, 103, 83,  191, 171, 151, 147, 175, 155, 135, 131, 223, 203,
    183, 179, 207, 187, 167, 163, 255, 235, 231, 211, 239, 219, 215, 195, 242, 242, 250, 250,
    246, 246, 226, 226, 196, 196, 196, 196, 196, 196, 196, 196,

    5,   5,   5,   5,   1,   1,   1,   1,   62,  62,  46,  46,  25,  25,  25,  25,  95,  43,
    39,  3,   78,  78,  22,  22,  110, 110, 58,  58,  54,  54,  18,  18,  126, 126, 74,  74,
    70,  70,  34,  34,  66,  66,  90,  90,  86,  86,  50,  50,  142, 142, 106, 106, 102, 102,
    82,  82,  175, 139, 135, 115, 159, 123, 119, 99,  163, 171, 167, 147, 191, 155, 151, 131,
    223, 203, 199, 195, 207, 187, 183, 179, 231, 227, 235, 215, 218, 218, 210, 210, 254, 254,
    250, 250, 246, 246, 242, 242, 236, 236, 236, 236, 236, 236, 236, 236,

    111, 95,  79,  63,  47,  27,  7,   0,   71,  75,  55,  59,  39,  127, 43,  23,  35,  107,
    103, 19,  143, 91,  87,  3,   99,  83,  139, 67,  159, 123, 119, 51,  191, 171, 151, 131,
    175, 155, 135, 115, 179, 203, 183, 163, 207, 187, 167, 147, 231, 211, 223, 219, 215, 195,
    198, 198, 246, 246, 226, 226, 238, 238, 234, 234, 253, 253, 253, 253, 249, 249, 249, 249,
    240, 240, 240, 240, 240, 240, 240, 240};

/*-----------------------------------------------------------------------*/
/* For given bits in the bitstream the decoded codeword consists of 2    */
/* fields:                                                               */
/* | targetcoefftokenidx(6) | suffix(2) |                                */
/*-----------------------------------------------------------------------*/

const UWORD8 g_au1_codegx_svc[312] = {
    16,  16,  16,  16,  16,  16,  16,  16,  4,   4,   4,   4,   4,   4,   4,   4,   8,   8,   8,
    8,   8,   8,   8,   8,   22,  22,  18,  18,  13,  13,  13,  13,  34,  34,  30,  30,  25,  25,
    25,  25,  50,  50,  46,  46,  42,  42,  38,  38,  66,  66,  62,  62,  58,  58,  54,  54,  82,
    82,  78,  78,  74,  74,  70,  70,  98,  98,  94,  94,  90,  90,  86,  86,  131, 127, 123, 119,
    115, 111, 107, 103, 163, 159, 155, 151, 147, 143, 139, 135, 195, 191, 187, 183, 179, 175, 171,
    167, 231, 227, 223, 219, 215, 211, 207, 203, 246, 246, 242, 242, 238, 238, 234, 234, 196, 196,
    196, 196, 196, 196, 196, 196, 5,   5,   5,   5,   29,  29,  29,  29,  18,  18,  14,  14,  9,
    9,   9,   9,   43,  39,  35,  31,  26,  26,  22,  22,  58,  58,  54,  54,  50,  50,  46,  46,
    74,  74,  70,  70,  66,  66,  62,  62,  90,  90,  86,  86,  82,  82,  78,  78,  106, 106, 102,
    102, 98,  98,  94,  94,  139, 135, 131, 127, 123, 119, 115, 111, 171, 167, 163, 159, 155, 151,
    147, 143, 203, 199, 195, 191, 187, 183, 179, 175, 227, 223, 231, 219, 210, 210, 206, 206, 234,
    234, 246, 246, 242, 242, 238, 238, 212, 212, 212, 212, 212, 212, 212, 212, 31,  27,  23,  19,
    15,  11,  7,   64,  63,  59,  55,  51,  47,  43,  39,  35,  95,  91,  87,  83,  79,  75,  71,
    67,  127, 123, 119, 115, 111, 107, 103, 99,  159, 155, 151, 147, 143, 139, 135, 131, 191, 187,
    183, 179, 175, 171, 167, 163, 219, 215, 211, 207, 203, 199, 194, 194, 234, 234, 230, 230, 226,
    226, 222, 222, 241, 241, 241, 241, 237, 237, 237, 237, 244, 244, 244, 244, 244, 244, 244, 244,
    64,  64,  64,  64,  64,  64,  64,  64

};

/*---------------------------------------------------------------------------*/
/* A lookup table, when nC>=8, to get the targetcoefftokenidx                */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_target_coeff_token_idx[68] = {
    0,  0,  0,  0,  16, 1,  1,  1,  20, 8,  2,  2,  23, 11, 9,  3,  24, 13, 12, 4,  28, 15, 14,
    5,  30, 17, 18, 6,  31, 21, 22, 7,  32, 25, 26, 10, 36, 33, 29, 19, 40, 37, 34, 27, 44, 41,
    38, 35, 47, 45, 42, 39, 49, 48, 46, 43, 53, 50, 51, 52, 57, 54, 55, 56, 61, 58, 59, 60};

/*---------------------------------------------------------------------------*/
/* A lookup table for invTotalCoeff( coeffTokenIdx) and                      */
/*  invTrailingOnes( coeffTokenIdx )                                         */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_inv_tcoeff_t1[186] = {
    0,  5,  10, 15, 4,  9,  19, 14, 23, 8,  13, 18, 27, 12, 17, 22, 31, 16, 21, 26, 35,
    20, 25, 30, 39, 24, 29, 34, 43, 28, 33, 38, 32, 36, 37, 42, 47, 40, 41, 46, 51, 44,
    45, 50, 55, 48, 49, 54, 59, 53, 52, 57, 58, 63, 56, 61, 62, 67, 60, 65, 66, 64,

    0,  5,  10, 15, 19, 9,  23, 4,  13, 14, 27, 8,  17, 18, 31, 12, 21, 22, 35, 16, 25,
    26, 20, 24, 29, 30, 39, 28, 33, 34, 43, 32, 37, 38, 47, 36, 41, 42, 51, 40, 45, 46,
    44, 48, 49, 50, 55, 52, 53, 54, 59, 56, 58, 63, 57, 60, 61, 62, 67, 64, 65, 66,

    0,  5,  10, 15, 19, 23, 27, 31, 9,  14, 35, 13, 18, 17, 22, 21, 4,  25, 26, 39, 8,
    29, 30, 12, 16, 33, 34, 43, 20, 38, 24, 28, 32, 37, 42, 47, 36, 41, 46, 51, 40, 45,
    50, 55, 44, 49, 54, 48, 53, 52, 57, 58, 59, 56, 61, 62, 63, 60, 65, 66, 67, 64};

/*---------------------------------------------------------------------------*/
/* A lookup table for decoding the chroma nnz's and trailing 1's             */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_chroma_dc_nnz_t1[28] = {4,  4, 4,  4,  0,  0,  0,  0,  24, 24, 24, 24, 18, 46,
                                           22, 2, 49, 49, 33, 33, 41, 41, 37, 37, 57, 57, 53, 53};

/*****************************************************************************/
/* Total zeroes table                                                        */
/*****************************************************************************/

/*-----------------------------------------------------------------------*/
/* Contains information about tz table. Each entry consists of 3 fields  */
/* | table offset (8) | max zeroes(4) | bit offset(2) |                  */
/*-----------------------------------------------------------------------*/

const UWORD16 g_au2_tz_tbl_offsets[27] = {0,     37,    1178,  2778,  4374,  5718,  7066,
                                          8666,  10265, 11097, 11925, 12625, 13200, 13516,
                                          13768, 13956, 14092, 14344, 14532, 14677, 15374,
                                          16206, 17034, 17609, 17928, 18116, 18240};

/*-----------------------------------------------------------------------*/
/* Total zero table                                                      */
/*-----------------------------------------------------------------------*/

const UWORD8 g_au1_tz_tbl[285] = {
    0,  0,  9,  5,  17, 13, 25, 21, 33, 29, 41, 37, 49, 45, 57, 53, 60, 60,

    14, 10, 6,  2,  26, 22, 17, 17, 33, 33, 29, 29, 41, 41, 37, 37, 49, 49, 45, 45, 52, 52, 52,
    52, 56, 26, 14, 10, 6,  18, 2,  29, 29, 33, 33, 21, 21, 41, 41, 37, 37, 48, 48, 48, 48, 44,
    44, 44, 44, 52, 26, 22, 18, 6,  14, 10, 33, 33, 37, 37, 29, 29, 41, 41, 1,  1,  44, 44, 44,
    44, 48, 26, 22, 18, 14, 6,  2,  29, 29, 33, 33, 9,  9,  40, 40, 40, 40, 36, 36, 36, 36, 44,
    22, 18, 14, 10, 29, 29, 25, 25, 36, 36, 36, 36, 32, 32, 32, 32, 4,  4,  4,  4,  0,  0,  0,
    0,  40, 14, 10, 21, 21, 25, 25, 17, 17, 32, 32, 32, 32, 28, 28, 28, 28, 4,  4,  4,  4,  0,
    0,  0,  0,  36, 21, 17, 25, 13, 28, 28, 4,  4,  8,  8,  0,  0,  32,

    17, 13, 24, 24, 20, 20, 8,  8,  28, 28, 0,  0,  4,

    17, 13, 20, 20, 8,  8,  24, 24, 0,  0,  4,

    16, 16, 13, 21, 8,  8,  4,  4,  0,

    12, 8,  16, 4,  0,

    8,  12, 4,  0,

    8,  4,  0,

    4,  0,

    0,  4,  8,  12,

    0,  4,  8,

    0,  4,

    0,  0,  5,  9,  13, 17, 20, 20, 24, 24, 28,        /*11*/

    14, 18, 22, 26, 4,  4,  4,  4,  8,  8,  8,  8,  0, /*13*/

    13, 13, 18, 22, 8,  8,  8,  8,  4,  4,  4,  4,  0, /*13*/

    13, 13, 2,  18, 8,  8,  8,  8,  4,                 /*9*/

    9,  13, 4,  4,  0,                                 /*5*/

    8,  4,  0,                                         /*3*/

    4,  0                                              /*2*/
};

/*****************************************************************************/
/* Run before table                                                          */
/*****************************************************************************/

const UWORD8 g_au1_run_bef_tbl[64] = {0,  0,  0,  0,  0,  0,  0, 0, 5,  5,  5,  5,  1,  1,  1, 1,
                                      10, 10, 6,  6,  1,  1,  1, 1, 14, 14, 10, 10, 6,  6,  2, 2,
                                      19, 15, 10, 10, 6,  6,  2, 2, 23, 19, 15, 11, 6,  6,  2, 2,
                                      7,  11, 19, 15, 27, 23, 2, 2, 27, 27, 23, 19, 15, 11, 7, 3};

/*****************************************************************************/
/* CBP table                                                                 */
/*****************************************************************************/

/*-----------------------------------------------------------------------*/
/* Contains both inter and intra tables                                  */
/*-----------------------------------------------------------------------*/

const UWORD8 g_au1_intra_cbp[48] = {47, 31, 15, 0,  23, 27, 29, 30, 7,  11, 13, 14, 39, 43, 45, 46,
                                    16, 3,  5,  10, 12, 19, 21, 26, 28, 35, 37, 42, 44, 1,  2,  4,
                                    8,  17, 18, 20, 24, 6,  9,  22, 25, 32, 33, 34, 36, 40, 38, 41};

const UWORD8 g_au1_inter_cbp[48] = {0,  16, 1,  2,  4,  8,  32, 3,  5,  10, 12, 15, 47, 7,  11, 13,
                                    14, 6,  9,  31, 35, 37, 42, 44, 33, 34, 36, 40, 39, 43, 45, 46,
                                    17, 18, 20, 24, 19, 21, 26, 28, 23, 27, 29, 30, 22, 25, 38, 41};

/*---------------------------------------------------------------------------*/
/* Contains the cbp table for intra16x16 mb type                             */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_intra16x16_cbp[6] = {0, 16, 32, 15, 31, 47};

/*****************************************************************************/
/* Inverse scan table                                                        */
/*****************************************************************************/

/*-----------------------------------------------------------------------*/
/* Regular inverse scan tables                                           */
/*-----------------------------------------------------------------------*/

const UWORD8 g_au1_regular_inv_scan[16] = {0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15};

const UWORD8 g_au1_regular_inv_scan_field[16] = {0, 4, 1,  8,  12, 5, 9,  13,
                                                 2, 6, 10, 14, 3,  7, 11, 15};

const UWORD8 g_au1_regular_inv_scan8x8[64] = {
    0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33, 40, 48,
    41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23,
    30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63};

UWORD8 const g_au1_subblk_8x8_offsets[16] = {0,   0,   0,   0,   64,  64,  64,  64,
                                             128, 128, 128, 128, 192, 192, 192, 192};

/*---------------------------------------------------------------------------*/
/* 8x8 inverse scan tables                                               */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_prog_deinter_inv_scan[4][16] = {
    {0, 9, 17, 18, 12, 40, 27, 7, 35, 57, 29, 30, 58, 38, 53, 47},  /* for First subblock  */
    {1, 2, 24, 11, 19, 48, 20, 14, 42, 50, 22, 37, 59, 31, 60, 55}, /* for second subblock */
    {8, 3, 32, 4, 26, 41, 13, 21, 49, 43, 15, 44, 52, 39, 61, 62},  /* for third subblock  */
    {16, 10, 25, 5, 33, 34, 6, 28, 56, 36, 23, 51, 45, 46, 54, 63}  /* for fourth subblock */
};

const UWORD8 g_au1_prog_8x8_inv_scan[64] = {
    0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, 18, 11, 4,  5,  12, 19, 26, 33, 40, 48,
    41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23,
    30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63};

/*****************************************************************************/
/* SUBMB partition tables                                                    */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* Number of sub Mb's in 8x8 partition mode                              */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_num_sub_mb_part[4] = {1, 2, 2, 4};

/*---------------------------------------------------------------------------*/
/* Width and height of submb's in terms of 4x4 (for 8x8 partition mode)  */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_sub_mb_part_wd[4] = {2, 2, 1, 1};

const UWORD8 g_au1_sub_mb_part_ht[4] = {2, 1, 2, 1};

/*---------------------------------------------------------------------------*/
/* SubMB mc mode table                                                   */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_sub_mb_mc_mode[20] = {SUBMB_8x8, SUBMB_8x4, SUBMB_4x8, SUBMB_4x4, SUBMB_8x8,
                                         SUBMB_8x8, SUBMB_8x8, SUBMB_8x8, SUBMB_8x4, SUBMB_4x8,
                                         SUBMB_8x4, SUBMB_4x8, SUBMB_8x4, SUBMB_4x8, SUBMB_4x4,
                                         SUBMB_4x4, SUBMB_4x4,
                                         /* Self defined modes B DIRECT8x8 */
                                         SUBMB_4x4, SUBMB_4x4, SUBMB_4x4};

/*---------------------------------------------------------------------------*/
/* SubMb prediciton mode table                                           */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_sub_mb_pred_mode[20] = {
    PRED_L0,
    PRED_L0,
    PRED_L0,
    PRED_L0,
    B_DIRECT,
    PRED_L0,
    PRED_L1,
    BI_PRED,
    PRED_L0,
    PRED_L0,
    PRED_L1,
    PRED_L1,
    BI_PRED,
    BI_PRED,
    PRED_L0,
    PRED_L1,
    BI_PRED,
    /* Self defined modes for B DIRECT8x8 */
    BI_PRED,
    PRED_L0,
    PRED_L1,
};

/*****************************************************************************/
/* MB partition tables                                                       */
/*****************************************************************************/

/*---------------------------------------------------------------------------*/
/* Number of MB partitions                                               */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_num_mb_part[5] = {1, 2, 2, 4, 4};

/*---------------------------------------------------------------------------*/
/* MB partitions width and height in terms of submbs                     */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_mb_part_wd[5] = {4, 4, 2, 2, 2};

const UWORD8 g_au1_mb_part_ht[5] = {4, 2, 4, 2, 2};

/*---------------------------------------------------------------------------*/
/* MB MC mode of mb partitions                                               */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_mb_mc_mode[31] = {
    PRED_16x16, PRED_16x8, PRED_8x16, PRED_8x8, PRED_8x8R0, PRED_16x16, PRED_16x16, PRED_16x16,
    PRED_16x16, PRED_16x8, PRED_8x16, PRED_16x8, PRED_8x16, PRED_16x8, PRED_8x16, PRED_16x8,
    PRED_8x16, PRED_16x8, PRED_8x16, PRED_16x8, PRED_8x16, PRED_16x8, PRED_8x16, PRED_16x8,
    PRED_8x16, PRED_16x8, PRED_8x16, PRED_8x8,
    /* Self defined modes for B_SKIP and DIRECT16x16 */
    PRED_8x8, PRED_8x8, PRED_8x8};

/*---------------------------------------------------------------------------*/
/* MB prediciton mode table                                                  */
/*---------------------------------------------------------------------------*/

const WORD8 g_au1_mb_pred_mode[2][32] = {
    {
        PRED_L0,
        PRED_L0,
        PRED_L0,
        PRED_INVALID,
        PRED_INVALID,
        B_DIRECT,
        PRED_L0,
        PRED_L1,
        BI_PRED,
        PRED_L0,
        PRED_L0,
        PRED_L1,
        PRED_L1,
        PRED_L0,
        PRED_L0,
        PRED_L1,
        PRED_L1,
        PRED_L0,
        PRED_L0,
        PRED_L1,
        PRED_L1,
        BI_PRED,
        BI_PRED,
        BI_PRED,
        BI_PRED,
        BI_PRED,
        BI_PRED,
        PRED_INVALID,
        /* Self defined modes for B_SKIP and DIRECT16x16 */
        BI_PRED,
        PRED_L0,
        PRED_L1,
    },
    {PRED_INVALID, PRED_L0, PRED_L0, PRED_INVALID, PRED_INVALID, PRED_INVALID, PRED_INVALID,
     PRED_INVALID, PRED_INVALID, PRED_L0, PRED_L0, PRED_L1, PRED_L1, PRED_L1, PRED_L1, PRED_L0,
     PRED_L0, BI_PRED, BI_PRED, BI_PRED, BI_PRED, PRED_L0, PRED_L0, PRED_L1, PRED_L1, BI_PRED,
     BI_PRED, PRED_INVALID,
     /* Self defined modes for B_SKIP and DIRECT16x16 */
     PRED_INVALID, PRED_INVALID, PRED_INVALID}};

/*---------------------------------------------------------------------------*/
/* Neighbour partition address offsets table                                 */
/*---------------------------------------------------------------------------*/

const UWORD8 g_au1_neighbors_addr_offset[2][16 * 4] = {
    /* Each row has current, left, top, top right */
    /* Each row corresponds to sub_mb_num */

    /* Partition width 4 */
    {
        0,  0,  0, 1, 1,  0, 1, 2, 2,  1,  2, 3, 3,  2,  3,  5,  4,  1,  0,  1,  5, 4,
        1,  0,  6, 5, 2,  3, 7, 6, 3,  2,  8, 2, 4,  5,  9,  8,  5,  6,  10, 9,  6, 7,
        11, 10, 7, 6, 12, 3, 8, 9, 13, 12, 9, 8, 14, 13, 10, 11, 15, 14, 11, 10,
    },
    /* Partition width 8 */
    {/* Only alternate rows are valid */
     0, 0, 0, 2, 0,  0, 0, 0,  2, 1, 2, 4, 0,  0,  0,  0, 4, 1, 0,  2, 0, 0,
     0, 0, 6, 5, 2,  1, 0, 0,  0, 0, 8, 2, 4,  6,  0,  0, 0, 0, 10, 9, 6, 5,
     0, 0, 0, 0, 12, 3, 8, 10, 0, 0, 0, 0, 14, 13, 10, 9, 0, 0, 0,  0}};

/*---------------------------------------------------------------------------*/
/* Reference index comparison map table                                      */
/*---------------------------------------------------------------------------*/
const UWORD8 g_au1_ref_idx_comp_map[16 * 2 * 16] = {
    /* SUB MB NUMBER 0 */
    0, 1, 6, 7, 0, 1, 6, 7, 0, 1, 6, 7, 4, 5, 6, 7, /* Partition width 4 */
    0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, /* Partition width 8 */

    /* SUB MB NUMBER 1 */
    1, 1, 7, 7, 5, 5, 7, 7, 1, 1, 3, 3, 1, 1, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Partition width 8 */

    /* SUB MB NUMBER 2 */
    0, 1, 6, 7, 0, 1, 6, 7, 0, 1, 6, 7, 0, 1, 6, 7, /* Partition width 4 */
    0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, /* Partition width 8 */

    /* SUB MB NUMBER 3 */
    1, 1, 7, 7, 1, 1, 7, 7, 1, 1, 3, 3, 5, 5, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Partition width 8 */

    /* SUB MB NUMBER 4 */
    6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, /* Partition width 4 */
    2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, /* Partition width 8 */

    /* SUB MB NUMBER 5 */
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Partition width 8 */

    /* SUB MB NUMBER 6 */
    6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, /* Partition width 4 */
    2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, /* Partition width 8 */

    /* SUB MB NUMBER 7 */
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Partition width 8 */

    /* SUB MB NUMBER 8 */
    0, 1, 6, 7, 0, 1, 6, 7, 0, 1, 6, 7, 0, 1, 6, 7, /* Partition width 4 */
    0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, /* Partition width 8 */

    /* SUB MB NUMBER 9 */
    1, 1, 3, 3, 5, 5, 7, 7, 1, 1, 3, 3, 5, 5, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Partition width 8 */

    /* SUB MB NUMBER 10 */
    0, 1, 6, 7, 0, 1, 6, 7, 0, 1, 6, 7, 0, 1, 6, 7, /* Partition width 4 */
    0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, /* Partition width 8 */

    /* SUB MB NUMBER 11 */
    1, 1, 7, 7, 1, 1, 7, 7, 1, 1, 7, 7, 1, 1, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Partition width 8 */

    /* SUB MB NUMBER 12 */
    6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, /* Partition width 4 */
    2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, /* Partition width 8 */

    /* SUB MB NUMBER 13 */
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Partition width 8 */

    /* SUB MB NUMBER 14 */
    6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, /* Partition width 4 */
    2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, 2, 7, /* Partition width 8 */

    /* SUB MB NUMBER 15 */
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, /* Partition width 4 */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  /* Partition width 8 */

};

/*-----------------------------------------------------------------------*/
/* SUB MB index                                                          */
/*-----------------------------------------------------------------------*/

const UWORD8 g_au1_sub_mb_idx_mod[16] = {
    0, 0,      /* 16x16 */
    0, 8,      /* 16x8 */
    0, 2,      /* 8x16 */
    0, 0,      /* 8x8 */
    0, 4,      /* 8x4 */
    0, 1,      /* 4x8 */
    0, 1, 3, 1 /* 4x4 */
};

/*****************************************************************************/
/* Raster scan offset table                                                  */
/*****************************************************************************/

const UWORD8 g_au1_sub_blk_rast_scan_offsets[16] = {0, 1, 4,  5,  2,  3,  6,  7,
                                                    8, 9, 12, 13, 10, 11, 14, 15};

/*****************************************************************************/
/*Motion and mode computation tables                                         */
/*****************************************************************************/

/* B MB TYPES */
const UWORD8 g_au1_eb_mb_type[36] = {
    B_L0_16x16,   B_L0_16x16,   B_L0_16x16,   B_L1_16x16,   B_L1_16x16,   B_L1_16x16,
    B_BI_16x16,   B_BI_16x16,   B_BI_16x16,   B_L0_L0_16x8, B_L0_L1_16x8, B_L0_BI_16x8,
    B_L1_L0_16x8, B_L1_L1_16x8, B_L1_BI_16x8, B_BI_L0_16x8, B_BI_L1_16x8, B_BI_BI_16x8,
    B_L0_L0_8x16, B_L0_L1_8x16, B_L0_BI_8x16, B_L1_L0_8x16, B_L1_L1_8x16, B_L1_BI_8x16,
    B_BI_L0_8x16, B_BI_L1_8x16, B_BI_BI_8x16, B_8x8,        B_8x8,        B_8x8,
    B_8x8,        B_8x8,        B_8x8,        B_8x8,        B_8x8,        B_8x8};

/* P MB TYPES */
const UWORD8 g_au1_ep_mb_type[4] = {P_L0_16x16, P_L0_L0_16x8, P_L0_L0_8x16, P_8x8};

/* P SUB MB TYPES */
const UWORD8 g_au1_ep_submb_type[4] = {P_L0_8x8, P_L0_8x4, P_L0_4x8, P_L0_4x4};

/* B SUB MB TYPES */
const UWORD8 g_au1_eb_submb_type[12] = {B_L0_8x8, B_L1_8x8, B_BI_8x8, B_L0_8x4, B_L1_8x4, B_BI_8x4,
                                        B_L0_4x8, B_L1_4x8, B_BI_4x8, B_L0_4x4, B_L1_4x4, B_BI_4x4};

/*****************************************************************************/
/* Deblocking related tables                                                 */
/*****************************************************************************/

/* chroma QP values luma Qp is used to index to this table */
const UWORD8 g_au1_qp_scale_chroma[52] = {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12,
                                          13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
                                          26, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 34, 35,
                                          35, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 39, 39};

/* alpha table used in deblocking */
const UWORD8 g_au1_alpha_table[52] = {0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
                                      0,  0,  0,  4,   4,   5,   6,   7,   8,   9,   10,  12,  13,
                                      15, 17, 20, 22,  25,  28,  32,  36,  40,  45,  50,  56,  63,
                                      71, 80, 90, 101, 113, 127, 144, 162, 182, 203, 226, 255, 255};

/* clip table used in deblcoking */
const UWORD8 g_au1_clip_table_deblk[75] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,
    8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
    27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
    46, 47, 48, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51};

/* Beta table used in deblocking*/
const UWORD8 g_au1_beta_table[52] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,
    6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18};

/* clip table used baed on index BS and other vakues */
const UWORD8 g_au1_clip_table[52][4] = {
    {0, 0, 0, 0},    {0, 0, 0, 0},   {0, 0, 0, 0},   {0, 0, 0, 0},   {0, 0, 0, 0},
    {0, 0, 0, 0},    {0, 0, 0, 0},   {0, 0, 0, 0},   {0, 0, 0, 0},   {0, 0, 0, 0},
    {0, 0, 0, 0},    {0, 0, 0, 0},   {0, 0, 0, 0},   {0, 0, 0, 0},   {0, 0, 0, 0},
    {0, 0, 0, 0},    {0, 0, 0, 0},   {0, 0, 0, 1},   {0, 0, 0, 1},   {0, 0, 0, 1},
    {0, 0, 0, 1},    {0, 0, 1, 1},   {0, 0, 1, 1},   {0, 1, 1, 1},   {0, 1, 1, 1},
    {0, 1, 1, 1},    {0, 1, 1, 1},   {0, 1, 1, 2},   {0, 1, 1, 2},   {0, 1, 1, 2},
    {0, 1, 1, 2},    {0, 1, 2, 3},   {0, 1, 2, 3},   {0, 2, 2, 3},   {0, 2, 2, 4},
    {0, 2, 3, 4},    {0, 2, 3, 4},   {0, 3, 3, 5},   {0, 3, 4, 6},   {0, 3, 4, 6},
    {0, 4, 5, 7},    {0, 4, 5, 8},   {0, 4, 6, 9},   {0, 5, 7, 10},  {0, 6, 8, 11},
    {0, 6, 8, 13},   {0, 7, 10, 14}, {0, 8, 11, 16}, {0, 9, 12, 18}, {0, 10, 13, 20},
    {0, 11, 15, 23}, {0, 13, 17, 25}};

/*****************************************************************************/
/* QUANTIZATION TABLES                                                       */
/*****************************************************************************/

const UWORD8 g_au1_luma_to_chroma_qp_map[52] = {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12,
                                                13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
                                                26, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 34, 35,
                                                35, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 39, 39};

const UWORD8 g_au1_scale_factor_table[6] = {8, 9, 10, 11, 13, 14};

/*****************************************************************************/
/* SCALING MATRICIES TABLE                                                   */
/*****************************************************************************/

/* Default table used for INTRA 4x4 blocks */
const WORD16 g_ai2_default_intra4x4[16] = {6,  13, 13, 20, 20, 20, 28, 28,
                                           28, 28, 32, 32, 32, 37, 37, 42};

/* Default table used for INTER 4x4 blocks */
const WORD16 g_ai2_default_inter4x4[16] = {10, 14, 14, 20, 20, 20, 24, 24,
                                           24, 24, 27, 27, 27, 30, 30, 34};

/* Flat table used for 4x4 blocks */
const WORD16 g_ai2_flat_4x4[16] = {16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16};

/* Flat table used for 4x4 blocks */
const WORD16 g_ai2_flat_8x8[64] = {16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
                                   16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
                                   16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
                                   16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16};

/* Default table used for INTRA 8x8 blocks */
const WORD16 g_ai2_default_intra8x8[64] = {
    6,  10, 10, 13, 11, 13, 16, 16, 16, 16, 18, 18, 18, 18, 18, 23, 23, 23, 23, 23, 23, 25,
    25, 25, 25, 25, 25, 25, 27, 27, 27, 27, 27, 27, 27, 27, 29, 29, 29, 29, 29, 29, 29, 31,
    31, 31, 31, 31, 31, 33, 33, 33, 33, 33, 36, 36, 36, 36, 38, 38, 38, 40, 40, 42};

/* Default table used for INTER 8x8 blocks */
const WORD16 g_ai2_default_inter8x8[64] = {
    9,  13, 13, 15, 13, 15, 17, 17, 17, 17, 19, 19, 19, 19, 19, 21, 21, 21, 21, 21, 21, 22,
    22, 22, 22, 22, 22, 22, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 27,
    27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 30, 30, 30, 30, 32, 32, 32, 33, 33, 35};

/* V(qp%6) table */
const WORD8 g_ai1_scale_quant_matrix[6][16] = {
    {10, 13, 13, 10, 16, 10, 13, 13, 13, 13, 16, 10, 16, 13, 13, 16},
    {11, 14, 14, 11, 18, 11, 14, 14, 14, 14, 18, 11, 18, 14, 14, 18},
    {13, 16, 16, 13, 20, 13, 16, 16, 16, 16, 20, 13, 20, 16, 16, 20},
    {14, 18, 18, 14, 23, 14, 18, 18, 18, 18, 23, 14, 23, 18, 18, 23},
    {16, 20, 20, 16, 25, 16, 20, 20, 20, 20, 25, 16, 25, 20, 20, 25},
    {18, 23, 23, 18, 29, 18, 23, 23, 23, 23, 29, 18, 29, 23, 23, 29}};

/* V(qp%6) table for 8x8 */
const UWORD8 g_ai1_8x8_scale_quant_matrix[6][64] = {
    {20, 19, 19, 25, 18, 25, 19, 24, 24, 19, 20, 18, 32, 18, 20, 19, 19, 24, 24, 19, 19, 25,
     18, 25, 18, 25, 18, 25, 19, 24, 24, 19, 19, 24, 24, 19, 18, 32, 18, 20, 18, 32, 18, 24,
     24, 19, 19, 24, 24, 18, 25, 18, 25, 18, 19, 24, 24, 19, 18, 32, 18, 24, 24, 18},
    {22, 21, 21, 28, 19, 28, 21, 26, 26, 21, 22, 19, 35, 19, 22, 21, 21, 26, 26, 21, 21, 28,
     19, 28, 19, 28, 19, 28, 21, 26, 26, 21, 21, 26, 26, 21, 19, 35, 19, 22, 19, 35, 19, 26,
     26, 21, 21, 26, 26, 19, 28, 19, 28, 19, 21, 26, 26, 21, 19, 35, 19, 26, 26, 19},
    {26, 24, 24, 33, 23, 33, 24, 31, 31, 24, 26, 23, 42, 23, 26, 24, 24, 31, 31, 24, 24, 33,
     23, 33, 23, 33, 23, 33, 24, 31, 31, 24, 24, 31, 31, 24, 23, 42, 23, 26, 23, 42, 23, 31,
     31, 24, 24, 31, 31, 23, 33, 23, 33, 23, 24, 31, 31, 24, 23, 42, 23, 31, 31, 23},
    {28, 26, 26, 35, 25, 35, 26, 33, 33, 26, 28, 25, 45, 25, 28, 26, 26, 33, 33, 26, 26, 35,
     25, 35, 25, 35, 25, 35, 26, 33, 33, 26, 26, 33, 33, 26, 25, 45, 25, 28, 25, 45, 25, 33,
     33, 26, 26, 33, 33, 25, 35, 25, 35, 25, 26, 33, 33, 26, 25, 45, 25, 33, 33, 25},
    {32, 30, 30, 40, 28, 40, 30, 38, 38, 30, 32, 28, 51, 28, 32, 30, 30, 38, 38, 30, 30, 40,
     28, 40, 28, 40, 28, 40, 30, 38, 38, 30, 30, 38, 38, 30, 28, 51, 28, 32, 28, 51, 28, 38,
     38, 30, 30, 38, 38, 28, 40, 28, 40, 28, 30, 38, 38, 30, 28, 51, 28, 38, 38, 28},
    {36, 34, 34, 46, 32, 46, 34, 43, 43, 34, 36, 32, 58, 32, 36, 34, 34, 43, 43, 34, 34, 46,
     32, 46, 32, 46, 32, 46, 34, 43, 43, 34, 34, 43, 43, 34, 32, 58, 32, 36, 32, 58, 32, 43,
     43, 34, 34, 43, 43, 32, 46, 32, 46, 32, 34, 43, 43, 34, 32, 58, 32, 43, 43, 32}

};

/*****************************************************************************/
/* CABAC engine tables                                                       */
/*****************************************************************************/

const UWORD8 g_au1_sig_coeff_ctxt_inc[64] = {
    0, 1, 2, 3,  4,  5,  5,  4, 4, 3,  3,  4, 4,  4,  5,  5,  4,  4,  4,  4,  3,  3,
    6, 7, 7, 7,  8,  9,  10, 9, 8, 7,  7,  6, 11, 12, 13, 11, 6,  7,  8,  9,  14, 10,
    9, 8, 6, 11, 12, 13, 11, 6, 9, 14, 10, 9, 11, 12, 13, 11, 14, 10, 12, 255};

const UWORD8 g_au1_last_coeff_ctxt_inc[64] = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                                              3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
                                              5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 255};

/*-----------------------------------------------------------------------*/
/* Range table                                                           */
/*-----------------------------------------------------------------------*/

const UWORD8 g_au1_cabac_rtab[64][4] = {
    {128, 176, 208, 240}, {128, 167, 197, 227}, {128, 158, 187, 216}, {123, 150, 178, 205},
    {116, 142, 169, 195}, {111, 135, 160, 185}, {105, 128, 152, 175}, {100, 122, 144, 166},
    {95, 116, 137, 158},  {90, 110, 130, 150},  {85, 104, 123, 142},  {81, 99, 117, 135},
    {77, 94, 111, 128},   {73, 89, 105, 122},   {69, 85, 100, 116},   {66, 80, 95, 110},
    {62, 76, 90, 104},    {59, 72, 86, 99},     {56, 69, 81, 94},     {53, 65, 77, 89},
    {51, 62, 73, 85},     {48, 59, 69, 80},     {46, 56, 66, 76},     {43, 53, 63, 72},
    {41, 50, 59, 69},     {39, 48, 56, 65},     {37, 45, 54, 62},     {35, 43, 51, 59},
    {33, 41, 48, 56},     {32, 39, 46, 53},     {30, 37, 43, 50},     {29, 35, 41, 48},
    {27, 33, 39, 45},     {26, 31, 37, 43},     {24, 30, 35, 41},     {23, 28, 33, 39},
    {22, 27, 32, 37},     {21, 26, 30, 35},     {20, 24, 29, 33},     {19, 23, 27, 31},
    {18, 22, 26, 30},     {17, 21, 25, 28},     {16, 20, 23, 27},     {15, 19, 22, 25},
    {14, 18, 21, 24},     {14, 17, 20, 23},     {13, 16, 19, 22},     {12, 15, 18, 21},
    {12, 14, 17, 20},     {11, 14, 16, 19},     {11, 13, 15, 18},     {10, 12, 15, 17},
    {10, 12, 14, 16},     {9, 11, 13, 15},      {9, 11, 12, 14},      {8, 10, 12, 14},
    {8, 9, 11, 13},       {7, 9, 11, 12},       {7, 9, 10, 12},       {7, 8, 10, 11},
    {6, 8, 9, 11},        {6, 7, 9, 10},        {6, 7, 8, 9},         {2, 2, 2, 2}};

/*-----------------------------------------------------------------------*/
/* Next state MPS_LPS table                                                  */
/*-----------------------------------------------------------------------*/

const UWORD16 g_au2_cabac_next_state_mps_lps[64] = {
    0x100,  0x200,  0x301,  0x402,  0x502,  0x604,  0x704,  0x805,  0x906,  0xa07,  0xb08,
    0xc09,  0xd09,  0xe0b,  0xf0b,  0x100c, 0x110d, 0x120d, 0x130f, 0x140f, 0x1510, 0x1610,
    0x1712, 0x1812, 0x1913, 0x1a13, 0x1b15, 0x1c15, 0x1d16, 0x1e16, 0x1f17, 0x2018, 0x2118,
    0x2219, 0x231a, 0x241a, 0x251b, 0x261b, 0x271c, 0x281d, 0x291d, 0x2a1e, 0x2b1e, 0x2c1e,
    0x2d1f, 0x2e20, 0x2f20, 0x3021, 0x3121, 0x3221, 0x3322, 0x3422, 0x3523, 0x3623, 0x3723,
    0x3824, 0x3924, 0x3a24, 0x3b25, 0x3c25, 0x3d25, 0x3e26, 0x3e26, 0x3f3f};

/*****************************************************************************/
/*                                                                           */
/*  Function Name :  isvcd_ref_lyr_part_idc                                   */
/*                                                                           */
/*  Description   : this function computes the reference layer partition map */
/*                  for all the 4x4 partitions of the current MB             */
/*                                                                           */
/*  Inputs        : pv_comp_mode_mv_ctxt : mode motion handle                */
/*                  ai4_ref_part_idc : pointer to reference layer partition  */
/*                    indentification                                        */
/*                  pi4_intra_flag  : pointer to store the intra flag        */
/*                  i4_mb_addr      : current MB address                     */
/*  Globals       : none                                                     */
/*  Processing    : it projects the each 4x4 block onto the refernce layer   */
/*                  and gets the co-located location. it checks the  MB mode */
/*                  of the reference layer MB for INTRA and performs actions */
/*                  appropriately. it modifies the intra declared partitions */
/*                  for non-dydaic cases                                     */
/*  Outputs       : packed offset x and offset y in the refernce layer array */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
void isvcd_ref_lyr_part_idc(void *pv_comp_mode_mv_ctxt, WORD32 ai4_ref_part_idc[4][4],
                            WORD32 *pi4_intra_flag, void *pv_mb_params)
{
    /*! Flow of the module is as follows                                   */
    /*! 1. runs loops over the 16 4x4 blocks and gets teh reference layer
    patition information by projecting the 1,1 locations of
    each block                                                      */
    /*! 2. if the projected partition is in INTRA MB then its stores -1
    to the partition idc array                                      */
    /*! 3. if projected partition is in INTER MB then it packs and stores
    the offsets form the starting pointer in the part_idc array     */
    /*! 4. IN non dyaydic cases. the part idc having -1 are replaced by
    neighbours if the current MB projected is not INTRA             */
    /*! 5. the -1 values are replaced first on a 4x4 inside an 8x8 basis   */
    /*! 6. in second iteration -1 are replaced at an 8x8 basis             */
    /*! 7. stores the intra MB status in the location given                */

    mode_motion_ctxt_t *ps_ctxt;
    mode_motion_lyr_ctxt *ps_lyr_mem;
    inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms;
    WORD32 i4_blk_y, i4_blk_x;
    WORD32 i4_mb_x, i4_mb_y;
    WORD32 i4_intra_mb_flag;
    WORD32 i4_inter_lyr_mb_prms_stride;
    dec_mb_info_t *ps_mb_params;

    ps_mb_params = (dec_mb_info_t *) pv_mb_params;
    ps_ctxt = (mode_motion_ctxt_t *) pv_comp_mode_mv_ctxt;

    /* get the current layer ctxt */
    ps_lyr_mem = &ps_ctxt->as_res_lyr_mem[ps_ctxt->i4_res_id];

    /* ref layer mb mode */
    ps_inter_lyr_mb_prms = (inter_lyr_mb_prms_t *) ps_lyr_mem->s_ref_mb_mode.pv_buffer;
    i4_inter_lyr_mb_prms_stride = ps_lyr_mem->s_ref_mb_mode.i4_num_element_stride;

    /* derive the MB_X and MB_Y for the current MB */
    i4_mb_x = ps_mb_params->u2_mbx;
    i4_mb_y = ps_mb_params->u2_mby;

    /* set the intra MB flag to default TRUE */
    i4_intra_mb_flag = SVCD_TRUE;

    /*-----------------------------------------------------------------------*/
    /* derive the reference layer part idc for all 16 partitions             */
    /*-----------------------------------------------------------------------*/
    for(i4_blk_y = 0; i4_blk_y < NUM_SUB_MB_PARTS; i4_blk_y++)
    {
        for(i4_blk_x = 0; i4_blk_x < NUM_SUB_MB_PARTS; i4_blk_x++)
        {
            WORD32 i4_curr_x, i4_curr_y;
            WORD32 i4_ref_x, i4_ref_y;
            WORD32 i4_ref_mb_x, i4_ref_mb_y;
            WORD8 i1_ref_mb_mode;
            inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_temp;

            i4_curr_x = (i4_mb_x << 4) + (i4_blk_x << 2) + 1;
            i4_curr_y = (i4_mb_y << 4) + (i4_blk_y << 2) + 1;

            /* get the colocated position in the refernce layer */
            i4_ref_x = ps_lyr_mem->pi2_ref_loc_x[i4_curr_x];
            i4_ref_y = ps_lyr_mem->pi2_ref_loc_y[i4_curr_y];

            i4_ref_x = CLIP3(0, ((ps_lyr_mem->i4_ref_width) - 1), i4_ref_x);

            i4_ref_y = CLIP3(0, ((ps_lyr_mem->i4_ref_height) - 1), i4_ref_y);

            /* get the reference mb x and y */
            i4_ref_mb_x = (i4_ref_x >> 4);
            i4_ref_mb_y = (i4_ref_y >> 4);

            /* get the appropriate mb params in reference layer */
            ps_inter_lyr_mb_prms_temp = ps_inter_lyr_mb_prms + i4_ref_mb_x;
            ps_inter_lyr_mb_prms_temp += i4_ref_mb_y * i4_inter_lyr_mb_prms_stride;

            i1_ref_mb_mode = ps_inter_lyr_mb_prms_temp->i1_mb_mode;

            /* check if the MB mode of the refernce MB is Intra*/
            if(i1_ref_mb_mode > SVC_INTER_MB)
            {
                /* store the -1 value */
                ai4_ref_part_idc[i4_blk_y][i4_blk_x] = -1;
            }
            else
            {
                /* pack and store the reference x and y */
                ai4_ref_part_idc[i4_blk_y][i4_blk_x] = (i4_ref_y << 16) + i4_ref_x;
                i4_intra_mb_flag = SVCD_FALSE;
            }

        } /* end of block x loop */

    }     /* end of block y loop */

    /*************************************************************************/
    /* if the restricted spatial resolution change flag is 0                 */
    /* modify the part_idc for all the partitions                            */
    /*************************************************************************/
    if(SVCD_FALSE == (ps_lyr_mem->ps_curr_lyr_res_prms->u1_rstrct_res_change_flag) &&
       (SVCD_FALSE == i4_intra_mb_flag))
    {
        /* replace values of "-1" on a 4x4 block basis */
        WORD32 i4_xp, i4_yp;
        WORD32 i4_indx_x, i4_indx_y;
        WORD32 ai4_flag_8x8[2][2] = {SVCD_FALSE};

        /* loop over (4) 8x8 partitions */
        for(i4_yp = 0; i4_yp < 2; i4_yp++)
        {
            for(i4_xp = 0; i4_xp < 2; i4_xp++)
            {
                WORD32 i4_xs, i4_ys;
                WORD32 ai4_flag_4x4[2][2] = {SVCD_FALSE};

                /* loop over (4) 4x4 partitions */
                for(i4_ys = 0; i4_ys < 2; i4_ys++)
                {
                    for(i4_xs = 0; i4_xs < 2; i4_xs++)
                    {
                        /* index to the exact 4x4 block */
                        i4_indx_y = (i4_yp << 1) + i4_ys;
                        i4_indx_x = (i4_xp << 1) + i4_xs;

                        /* check if the current part idc is -1*/
                        if(ai4_ref_part_idc[i4_indx_y][i4_indx_x] == -1)
                        {
                            WORD32 i4_temp_x = 1 - i4_xs;
                            WORD32 i4_temp_y = 1 - i4_ys;
                            WORD32 i4_temp_part_y = (i4_yp << 1) + i4_temp_y;

                            WORD32 i4_temp_part_x = (i4_xp << 1) + i4_temp_x;

                            ai4_flag_4x4[i4_ys][i4_xs] = SVCD_TRUE;

                            /* replace with appropriate values */
                            if((SVCD_FALSE == ai4_flag_4x4[i4_ys][i4_temp_x]) &&
                               (ai4_ref_part_idc[i4_indx_y][i4_temp_part_x] != -1))
                            {
                                ai4_ref_part_idc[i4_indx_y][i4_indx_x] =
                                    ai4_ref_part_idc[i4_indx_y][i4_temp_part_x];
                            }
                            else if((SVCD_FALSE == ai4_flag_4x4[i4_temp_y][i4_xs]) &&
                                    (ai4_ref_part_idc[i4_temp_part_y][i4_indx_x] != -1))
                            {
                                ai4_ref_part_idc[i4_indx_y][i4_indx_x] =
                                    ai4_ref_part_idc[i4_temp_part_y][i4_indx_x];
                            }
                            else if((SVCD_FALSE == ai4_flag_4x4[i4_temp_y][i4_temp_x]) &&
                                    (ai4_ref_part_idc[i4_temp_part_y][i4_temp_part_x] != -1))
                            {
                                ai4_ref_part_idc[i4_indx_y][i4_indx_x] =
                                    ai4_ref_part_idc[i4_temp_part_y][i4_temp_part_x];
                            }
                        } /* end of part idc equal to -1 check */

                    }     /* end of sub partition xs loop */

                }         /* end of sub partition ys loop */

            }             /* end of partition xp loop */

        }                 /* end of partition yp loop */

        /* replace values of "-1" on an 8x8 block basis */

        /* loop over (4) 8x8 partitions */
        for(i4_yp = 0; i4_yp < 2; i4_yp++)
        {
            for(i4_xp = 0; i4_xp < 2; i4_xp++)
            {
                WORD32 i4_yp_inv = 1 - i4_yp;
                WORD32 i4_xp_inv = 1 - i4_xp;
                WORD32 i4_xo_inv = (2 - i4_xp);
                WORD32 i4_yo_inv = (2 - i4_yp);
                i4_indx_x = (i4_xp << 1);
                i4_indx_y = (i4_yp << 1);

                /* check if the current part idc is -1*/
                if(ai4_ref_part_idc[i4_indx_y][i4_indx_x] == -1)
                {
                    ai4_flag_8x8[i4_yp][i4_xp] = SVCD_TRUE;

                    /* replace the -1 with appropriate values */
                    if(SVCD_FALSE == ai4_flag_8x8[i4_yp][i4_xp_inv] &&
                       ai4_ref_part_idc[i4_indx_y][i4_xo_inv] != -1)
                    {
                        ai4_ref_part_idc[i4_indx_y][i4_indx_x] =
                            ai4_ref_part_idc[i4_indx_y][i4_xo_inv];

                        ai4_ref_part_idc[i4_indx_y + 1][i4_indx_x] =
                            ai4_ref_part_idc[i4_indx_y + 1][i4_xo_inv];

                        ai4_ref_part_idc[i4_indx_y][i4_indx_x + 1] =
                            ai4_ref_part_idc[i4_indx_y][i4_xo_inv];

                        ai4_ref_part_idc[i4_indx_y + 1][i4_indx_x + 1] =
                            ai4_ref_part_idc[i4_indx_y + 1][i4_xo_inv];
                    }
                    else if(SVCD_FALSE == ai4_flag_8x8[i4_yp_inv][i4_xp] &&
                            ai4_ref_part_idc[i4_yo_inv][i4_indx_x] != -1)
                    {
                        ai4_ref_part_idc[i4_indx_y][i4_indx_x] =
                            ai4_ref_part_idc[i4_yo_inv][i4_indx_x];

                        ai4_ref_part_idc[i4_indx_y + 1][i4_indx_x] =
                            ai4_ref_part_idc[i4_yo_inv][i4_indx_x];

                        ai4_ref_part_idc[i4_indx_y][i4_indx_x + 1] =
                            ai4_ref_part_idc[i4_yo_inv][i4_indx_x + 1];

                        ai4_ref_part_idc[i4_indx_y + 1][i4_indx_x + 1] =
                            ai4_ref_part_idc[i4_yo_inv][i4_indx_x + 1];
                    }
                    else if(SVCD_FALSE == ai4_flag_8x8[i4_yp_inv][i4_xp_inv] &&
                            ai4_ref_part_idc[i4_yo_inv][i4_xo_inv] != -1)
                    {
                        ai4_ref_part_idc[i4_indx_y][i4_indx_x] =
                            ai4_ref_part_idc[i4_yo_inv][i4_xo_inv];

                        ai4_ref_part_idc[i4_indx_y + 1][i4_indx_x] =
                            ai4_ref_part_idc[i4_yo_inv][i4_xo_inv];

                        ai4_ref_part_idc[i4_indx_y][i4_indx_x + 1] =
                            ai4_ref_part_idc[i4_yo_inv][i4_xo_inv];

                        ai4_ref_part_idc[i4_indx_y + 1][i4_indx_x + 1] =
                            ai4_ref_part_idc[i4_yo_inv][i4_xo_inv];
                    }
                } /* end of part idc equal to -1 check */

            }     /* end of partition xp loop */

        }         /* end of partition yp loop */

    }             /* end of refinement of part idc for non dyadic case*/

    /* store the intra flag in the location provided */
    *pi4_intra_flag = i4_intra_mb_flag;

    return;
}
/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_check_motion                                        */
/*                                                                           */
/*  Description   :this function calculates the MV diff b/w to motion vectors*/
/*                 and returns 1 if it is under threshold equal to 0         */
/*                                                                           */
/*  Inputs        : pv_motion_prm_mb_part_a : pointer to motion struct part A*/
/*                  pv_motion_prm_mb_part_b : pointer to motion struct part B*/
/*                  i4_listx        : lists to be checked                    */
/*  Globals       : none                                                     */
/*  Processing    : it compares reference indcies fo given number of lists   */
/*                  it calculates the mv diff and compares it with 0         */
/*                  it does the above for given number of lists              */
/*  Outputs       : none                                                     */
/*  Returns       : 1 if matching 0 if not matching                          */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_check_motion(void *pv_motion_prm_mb_part_a, void *pv_motion_prm_mb_part_b,
                          WORD32 i4_listx)
{
    mv_pred_t *ps_part_a;
    mv_pred_t *ps_part_b;
    WORD32 i4_cntr;
    WORD32 i4_mv_treshold;
    WORD32 i4_flag = 0;

    ps_part_a = (mv_pred_t *) pv_motion_prm_mb_part_a;
    ps_part_b = (mv_pred_t *) pv_motion_prm_mb_part_b;

    for(i4_cntr = 0; i4_cntr < i4_listx; i4_cntr++)
    {
        /* calculate the absolute diff of both components */
        i4_mv_treshold = ABS((ps_part_a->i2_mv[2 * i4_cntr]) - (ps_part_b->i2_mv[2 * i4_cntr]));
        i4_mv_treshold +=
            ABS((ps_part_a->i2_mv[1 + 2 * i4_cntr]) - (ps_part_b->i2_mv[1 + 2 * i4_cntr]));

        if((0 == i4_mv_treshold) &&
           (ps_part_a->i1_ref_frame[i4_cntr] == ps_part_b->i1_ref_frame[i4_cntr]))
        {
            i4_flag = 1;
        }
        else
        {
            i4_flag = 0;
            return (i4_flag);
        }

    } /* end of loop over lists */

    return (i4_flag);
}
/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_get_min_positive                                    */
/*                                                                           */
/*  Description   : this utility return the minimum positive b/w the given   */
/*                  inputs                                                   */
/*                                                                           */
/*  Inputs        :  i4_input_1: value A , i4_input_2: value B               */
/*  Globals       :  none                                                    */
/*  Processing    :  if A & B are greater than -1 thenit returns MIN(A<B)    */
/*                   otherwise return MAX(A<B)                               */
/*  Outputs       :  none                                                    */
/*  Returns       :  minimum positive of the two inputs                      */
/*                                                                           */
/*  Issues        :  none                                                    */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_get_min_positive(WORD32 i4_input_1, WORD32 i4_input_2)
{
    UWORD32 u4_x, u4_y;
    WORD32 i4_min_positive;

    /* get positive values */
    u4_x = (UWORD32) i4_input_1;
    u4_y = (UWORD32) i4_input_2;

    /* logic and desired output

    u4_x     magnitude compare    u4_y           o/p
    +              >              +             u4_y
    +              <              +             u4_x
    +              =              +             u4_x
    -              >              -             u4_y
    -              <              -             u4_x
    -              =              -             u4_x
    0              =              0             u4_x
    -              n/a            +             u4_y
    +              n/a            -             u4_x

    */

    if((u4_y < u4_x) && (0 <= i4_input_2))
    {
        i4_min_positive = i4_input_2;
    }
    else
    {
        i4_min_positive = i4_input_1;
    }
    return (i4_min_positive);
}
/*****************************************************************************/
/*                                                                           */
/*  Function Name :  isvcd_motion_scale_crop_wdw_change                       */
/*                                                                           */
/*  Description   : This function does the up scaling of motion vectors and  */
/*                  for crop window change cases                             */
/*  Inputs        : pv_comp_mode_mv_ctxt : mode motion handle                */
/*                  ps_lyr_mem   : pointer current layer memory              */
/*                  ps_mb_params : pointer to mb params structure            */
/*                  ps_ref_mv    : pointer to reference MVs                  */
/*                  ps_motion_pred : pointer to current 4x4 part mv pred     */
/*                  i4_listx : lists to be processed                         */
/*                  i4_part_frm_x: horz location in the picture of the       */
/*                                 current sub partition                     */
/*                  i4_part_frm_y: vertical location in the picture of the   */
/*                                 current sub partition                     */
/*  Globals       :                                                          */
/*  Processing    : it takes care of cropping                                */
/*                  change flag                                              */
/*  Outputs       : it stores the interlayer MV pred in the structure        */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
void isvcd_motion_scale_crop_wdw_change(mode_motion_ctxt_t *ps_ctxt,
                                        mode_motion_lyr_ctxt *ps_lyr_mem,
                                        dec_mb_info_t *ps_mb_params, mv_pred_t *ps_ref_mv,
                                        mv_pred_t *ps_motion_pred, WORD32 i4_lists,
                                        WORD32 i4_part_frm_x, WORD32 i4_part_frm_y,
                                        void **ppv_map_ref_idx_to_poc, UWORD8 u1_list_x)
{
    ref_lyr_scaled_offset_t *ps_curr_lyr_offset;
    ref_lyr_scaled_offset_t *ps_ref_pic_lyr_offset;
    WORD32 i4_ref_lyr_width, i4_ref_lyr_height;
    WORD32 i4_curr_lyr_width, i4_curr_lyr_height;
    WORD32 i4_ref_indx;
    WORD32 i4_mv_x, i4_mv_y;
    WORD32 i4_x, i4_y;
    WORD32 i4_dox, i4_doy, i4_dsw, i4_dsh;
    WORD32 i4_scale_x, i4_scale_y;
    WORD8 *pi1_ref_idx_map;

    UNUSED(ps_ctxt);
    UNUSED(ps_mb_params);

    /* get the reference index */
    i4_ref_indx = ps_motion_pred->i1_ref_frame[u1_list_x];

    i4_mv_x = (WORD32) ps_ref_mv->i2_mv[2 * u1_list_x];
    i4_mv_y = (WORD32) ps_ref_mv->i2_mv[1 + 2 * u1_list_x];

    /* get the Map buffer pointer */
    if(0 == i4_lists)
    {
        pi1_ref_idx_map = (WORD8 *) ppv_map_ref_idx_to_poc;
    }
    else
    {
        pi1_ref_idx_map = (WORD8 *) (ppv_map_ref_idx_to_poc + POC_LIST_L0_TO_L1_DIFF);
    }

    /* get the Ref layer width and height */
    i4_ref_lyr_width = ps_lyr_mem->i4_ref_width;
    i4_ref_lyr_height = ps_lyr_mem->i4_ref_height;

    /* get the Scaled ref layer width and height */
    i4_curr_lyr_width = ps_lyr_mem->ps_curr_lyr_res_prms->u2_scaled_ref_width;
    i4_curr_lyr_height = ps_lyr_mem->ps_curr_lyr_res_prms->u2_scaled_ref_height;

    /* get the offset stucture pointer */
    ps_curr_lyr_offset = &ps_lyr_mem->ps_curr_lyr_res_prms->s_ref_lyr_scaled_offset;

    /* get the reference offset structure pointer */
    ps_ref_pic_lyr_offset = ps_lyr_mem->ps_ref_pic_lyr_offsets + pi1_ref_idx_map[i4_ref_indx];

    /* calculate the correction variables */
    i4_dox = ps_curr_lyr_offset->i2_left - ps_ref_pic_lyr_offset->i2_left;
    i4_doy = ps_curr_lyr_offset->i2_top - ps_ref_pic_lyr_offset->i2_top;
    i4_dsw = ps_curr_lyr_offset->i2_rt - ps_ref_pic_lyr_offset->i2_rt + i4_dox;
    i4_dsh = ps_curr_lyr_offset->i2_bot - ps_ref_pic_lyr_offset->i2_bot + i4_doy;

    i4_scale_x =
        (((i4_curr_lyr_width + i4_dsw) << 16) + (i4_ref_lyr_width >> 1)) / i4_ref_lyr_width;

    i4_scale_y =
        (((i4_curr_lyr_height + i4_dsh) << 16) + (i4_ref_lyr_height >> 1)) / i4_ref_lyr_height;

    /* scale the motion vectors */
    i4_mv_x = (i4_mv_x * i4_scale_x + 32768) >> 16;
    i4_mv_y = (i4_mv_y * i4_scale_y + 32768) >> 16;

    /* subtract the offsets */
    i4_x = i4_part_frm_x - ps_lyr_mem->i4_offset_x;
    i4_y = i4_part_frm_y - ps_lyr_mem->i4_offset_y;

    /* get the scale factors */
    i4_scale_x = (((4 * i4_dsw) << 16) + (i4_curr_lyr_width >> 1)) / i4_curr_lyr_width;
    i4_scale_y = (((4 * i4_dsh) << 16) + (i4_curr_lyr_height >> 1)) / i4_curr_lyr_height;

    /* add the correction */
    i4_mv_x += ((i4_x * i4_scale_x + 32768) >> 16) - 4 * i4_dox;
    i4_mv_y += ((i4_y * i4_scale_y + 32768) >> 16) - 4 * i4_doy;

    /* store the final motion vectors */
    ps_motion_pred->i2_mv[2 * u1_list_x] = i4_mv_x;
    ps_motion_pred->i2_mv[1 + 2 * u1_list_x] = i4_mv_y;
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name :  isvcd_interlayer_motion_scale                            */
/*                                                                           */
/*  Description   : This function does the up scaling of motion vectors and  */
/*                  and stores the inter layer MV and reference indices      */
/*                  in the mv prediction structure for a 4x4 part            */
/*  Inputs        : pv_comp_mode_mv_ctxt : mode motion handle                */
/*                  pi4_ref_part_idc   : pointer current 4x4 part ref_idc    */
/*                  pv_motion_pred : pointer to current 4x4 part mv pred     */
/*                  i4_listx : lists to be processed                         */
/*                  i4_part_frm_x: horz location in the picture of the       */
/*                                 current sub partition                     */
/*                  i4_part_frm_y: vertical location in the picture of the   */
/*                                 current sub partition                     */
/*  Globals       :                                                          */
/*  Processing    : it stores the default values if the refernce indx of     */
/*                  ref lyr partiton is -1. if not it upscales the motion    */
/*                  vectors based on scale factors. it takes care of cropping*/
/*                  change flag                                              */
/*  Outputs       : it stores the interlayer MV pred in the structure        */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_interlyr_motion_scale(void *pv_comp_mode_mv_ctxt, WORD32 *pi4_ref_part_idc,
                                   dec_mb_info_t *ps_mb_params, void *pv_motion_pred,
                                   WORD32 i4_listx, WORD32 i4_part_frm_x, WORD32 i4_part_frm_y,
                                   void **ppv_map_ref_idx_to_poc)
{
    /*! Flow of the module is as follows                                   */
    /*! 1. derive the offsets form part idc                                */
    /*! 2. takes the motion vector and scales it based on scale factor     */
    /*! 3. adds the correction factors for crop window change cases        */
    /*! 4. store the default motion params for intra projected blocks      */

    mode_motion_ctxt_t *ps_ctxt;
    mode_motion_lyr_ctxt *ps_lyr_mem;
    mv_pred_t *ps_motion_pred;
    mv_pred_t *ps_ref_mv;
    WORD32 i4_lists;
    WORD32 i4_ref_16x16_flag = 0;
    WORD32 i4_scale_x, i4_scale_y;
    WORD16 i2_max_mv_x, i2_max_mv_y;

    ps_ctxt = (mode_motion_ctxt_t *) pv_comp_mode_mv_ctxt;

    /* get the current layer ctxt */
    ps_lyr_mem = &ps_ctxt->as_res_lyr_mem[ps_ctxt->i4_res_id];

    /* ----------- Get the reference layer MV structure ---------- */
    {
        mv_pred_t *ps_ref_lyr_motion_prms;
        WORD32 i4_ref_x, i4_ref_y;
        WORD32 i4_ref_mb_x, i4_ref_mb_y;
        WORD32 i4_ref_width;

        ps_ref_lyr_motion_prms = (mv_pred_t *) ps_lyr_mem->pv_ref_mv_bank_l0;
        i4_ref_width = ps_lyr_mem->i4_ref_width;
        i2_max_mv_x = i4_ref_width << 2;
        i2_max_mv_y = ps_lyr_mem->i4_ref_height << 2;

        /* extract the reference x and y positions */
        i4_ref_x = (*pi4_ref_part_idc) & 0xFFFF;
        i4_ref_y = (*pi4_ref_part_idc) >> 16;

        /* get the reference mb x and y */
        i4_ref_mb_x = (i4_ref_x >> 4);
        i4_ref_mb_y = (i4_ref_y >> 4);

        /* get the reference layer motion struct pointing  */
        /* to first 4x4 partition of the refernce layer MB */
        ps_ref_mv = ps_ref_lyr_motion_prms + (i4_ref_mb_x << 4);
        ps_ref_mv += (i4_ref_mb_y * i4_ref_width);

        /* if reference layer mb type is non 16x16 */
        if(0 == i4_ref_16x16_flag)
        {
            /* increment the pointer to appropaite 4x4 */
            ps_ref_mv += ((i4_ref_x >> 2) & 0x03);
            ps_ref_mv += (((i4_ref_y >> 2) & 0x03) << 2);
        }
    }

    /* motion pred structure */
    ps_motion_pred = pv_motion_pred;

    /* retrive the scale factors */
    i4_scale_x = ps_lyr_mem->i4_scale_mv_x;
    i4_scale_y = ps_lyr_mem->i4_scale_mv_y;

    /* loop on the lists given as input */
    for(i4_lists = 0; i4_lists < i4_listx; i4_lists++)
    {
        WORD32 i4_mv_x, i4_mv_y;
        WORD16 i2_mv_x, i2_mv_y;

        /* if the refernce index is -1 set the default values */
        if(-1 == ps_ref_mv->i1_ref_frame[i4_lists])
        {
            ps_motion_pred->i1_ref_frame[i4_lists] = -1;
            ps_motion_pred->i2_mv[2 * i4_lists] = 0;
            ps_motion_pred->i2_mv[1 + 2 * i4_lists] = 0;
        }
        else
        {
            /* field MB and field pictures modification are present */
            /* currently not implemented */
            ps_motion_pred->i1_ref_frame[i4_lists] = ps_ref_mv->i1_ref_frame[i4_lists];

            i2_mv_x = ps_ref_mv->i2_mv[2 * i4_lists];
            i2_mv_y = ps_ref_mv->i2_mv[1 + 2 * i4_lists];
            i2_mv_x = CLIP3(-i2_max_mv_x, i2_max_mv_x, i2_mv_x);
            i2_mv_y = CLIP3(-i2_max_mv_y, i2_max_mv_y, i2_mv_y);
            /* scale the motion vectors */
            i4_mv_x = (i2_mv_x * i4_scale_x + 32768) >> 16;
            i4_mv_y = (i2_mv_y * i4_scale_y + 32768) >> 16;

            /* store the final motion vectors */
            ps_motion_pred->i2_mv[2 * i4_lists] = i4_mv_x;
            ps_motion_pred->i2_mv[1 + 2 * i4_lists] = i4_mv_y;

            /* if cropping change flag is present */
            if(SVCD_TRUE == ps_lyr_mem->ps_curr_lyr_res_prms->u1_cropping_change_flag)
            {
                /* over write the motion vectors x and y */
                isvcd_motion_scale_crop_wdw_change(ps_ctxt, ps_lyr_mem, ps_mb_params, ps_ref_mv,
                                                   ps_motion_pred, i4_listx, i4_part_frm_x,
                                                   i4_part_frm_y, ppv_map_ref_idx_to_poc, i4_lists);
            }
        }
    } /* end of lists loop */

    return (i4_ref_16x16_flag);
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_store_motion_map                                    */
/*                                                                           */
/*  Description   : this fucntion copies the  souce structure contents to    */
/*                  destination entires of part width x part height          */
/*                                                                           */
/*  Inputs        : pv_motion_pred : pointer to the source structure         */
/*                  ps_curr_lyr_motion_map : pointer to the destination      */
/*                  in the map                                               */
/*                  i4_src_stride : source stride                            */
/*                  i4_dst_stride : destination stride                       */
/*                  i4_part_width : width to be copied in terms of sub mbs   */
/*                  i4_part_height : height to be copied                     */
/*                  i4_src_update_flag : source update flag                  */
/*  Globals       : none                                                     */
/*  Processing    : it copies the src contents to destination                */
/*                                                                           */
/*  Outputs       : none                                                     */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
void isvcd_store_motion_map(void *pv_motion_pred, void *pv_curr_lyr_motion_map,
                            WORD32 i4_src_stride, WORD32 i4_dst_stride, WORD32 i4_part_width,
                            WORD32 i4_part_height, WORD32 i4_src_update_flag)
{
    /*! Flow of the module is as follows                                   */
    /*! 1. loops over part_width and part_height                           */
    /*! 2. copies the src params toi destination                           */
    /*! 3. updates the source pointer if src_update flag is set to 1       */

    WORD32 i4_i, i4_j;
    mv_pred_t *ps_mv_pred_src;
    mv_pred_t *ps_mv_map_dst;

    ps_mv_pred_src = (mv_pred_t *) pv_motion_pred;
    ps_mv_map_dst = (mv_pred_t *) pv_curr_lyr_motion_map;

    /* store the current motion pred to all the motion map structures */
    for(i4_i = 0; i4_i < i4_part_height; i4_i++)
    {
        for(i4_j = 0; i4_j < i4_part_width; i4_j++)
        {
            /* copy form source to destination */
            *(ps_mv_map_dst + i4_j) = *(ps_mv_pred_src + (i4_src_update_flag * i4_j));

        } /* end of loop over partition width */

        ps_mv_map_dst += i4_dst_stride;
        ps_mv_pred_src += (i4_src_stride * i4_src_update_flag);

    } /* end of loop over partition height */
    return;
}
/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_check_mv_diff                                       */
/*                                                                           */
/*  Description   :this function calculates the MV diff b/w to motion vectors*/
/*                 and returns 1 if it is under threshold                    */
/*                                                                           */
/*  Inputs        : pv_motion_prm_a : pointer to motion struct part A        */
/*                  pv_motion_prm_b : pointer to motion struct part B        */
/*                  i4_listx        : lists to be checked                    */
/*                  i4_actual_threshold : threshold with which the mv diff   */
/*                   is to be compared with                                  */
/*  Globals       : none                                                     */
/*  Processing    : it calculates the mv diff and compares it with threshold */
/*                  returns 1 if under threshold                              */
/*  Outputs       : none                                                     */
/*  Returns       : 1 if under threshold 0 if not under threshold            */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_check_mv_diff(void *pv_motion_prm_a, void *pv_motion_prm_b, WORD32 i4_listx,
                           WORD32 i4_actual_threshold)
{
    mv_pred_t *ps_part_a;
    mv_pred_t *ps_part_b;
    WORD32 i4_cntr;
    WORD32 i4_mv_treshold;
    WORD32 i4_flag;

    ps_part_a = (mv_pred_t *) pv_motion_prm_a;
    ps_part_b = (mv_pred_t *) pv_motion_prm_b;

    i4_flag = 1;
    for(i4_cntr = 0; i4_cntr < i4_listx; i4_cntr++)
    {
        /* calculate the absolute diff of both components */
        i4_mv_treshold = ABS((ps_part_a->i2_mv[2 * i4_cntr]) - (ps_part_b->i2_mv[2 * i4_cntr]));
        i4_mv_treshold +=
            ABS((ps_part_a->i2_mv[1 + (2 * i4_cntr)]) - (ps_part_b->i2_mv[1 + (2 * i4_cntr)]));

        if(i4_actual_threshold < i4_mv_treshold)
        {
            i4_flag = 0;
            break;
        }

    } /* end of loop over lists */
    return (i4_flag);
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name :  isvcd_interlayer_motion_submbmode_pred                   */
/*                                                                           */
/*  Description   : this function does the inter layer motion predcition for */
/*                   all sub partitions of a macro block                     */
/*                                                                           */
/*  Inputs        : pv_comp_mode_mv_ctxt : motion mode handle                */
/*                  pv_mb_params : pointer to MB params structure            */
/*                  ai4_ref_part_idc : ref partitons idc of all 4x4 blocks   */
/*                  pi4_sub_mb_mode  : pointer to store the sub mb modes     */
/*                  i4_mb_addr       : current mb address                    */
/*                  pi4_intra_flag   : location to store the intra status    */
/*  Globals       : none                                                     */
/*  Processing    : it computes the motion vectors and futher modifictaion is*/
/*                  done for NON -DYAdic cases                               */
/*  Outputs       : inter layer predicted motion vectors and ref indices     */
/*                  sub mbmodes of the 4 mb partitions                       */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
void isvcd_interlyr_motion_submbmode_pred(void *pv_comp_mode_mv_ctxt, void *pv_mb_params,
                                          void *pv_svc_mb_params, WORD32 ai4_ref_part_idc[4][4],
                                          WORD32 *pi4_sub_mb_mode, void *pv_dec)
{
    /*! Flow of the module is as follows                                   */
    /*! 1. if dyadic case it calculates the motion vectors based on dyadic
           scale factor and loop counts calculated at layer level          */
    /*! 2. if non dyadic then it calculates the motion vectors based on
            reference layer part idc                                        */
    /*! 3. does the motion vector modification for non dyayic cases, by
           calculating the minimum positive of reference indices of 4 4x4
           blocks and getiing a single reference index for 8x8             */
    /*! 4. if direct 8x8 inference is present and current slice is
           B OR EB, then it stores the corner motion vectors for each 8x8  */
    /*! 5. does the sub mb mode prediction and merging of motion vectors
           which are closely related by setting appropriate thresholds
           for MVs                                                         */
    /*! 6. stores the sub mb modes in the array given as input             */

    mode_motion_ctxt_t *ps_ctxt;
    mode_motion_lyr_ctxt *ps_lyr_mem;
    mv_pred_t *ps_motion_pred;
    dec_mb_info_t *ps_mb_params;
    dec_svc_mb_info_t *ps_svc_mb_params;
    WORD32 i4_blk_y, i4_blk_x;
    WORD32 i4_i;
    WORD32 i4_listx;
    WORD32 i4_mv_treshold;
    WORD32 ai4_temp_ref_indx[NUM_REF_LISTS][NUM_MB_PARTS] = {0};
    WORD32 i4_mb_x, i4_mb_y;
    WORD32 i4_mb_pic_x, i4_mb_pic_y;
    dec_struct_t *ps_dec;

    ps_dec = (dec_struct_t *) pv_dec;
    ps_ctxt = (mode_motion_ctxt_t *) pv_comp_mode_mv_ctxt;

    /* get the current layer ctxt */
    ps_lyr_mem = &ps_ctxt->as_res_lyr_mem[ps_ctxt->i4_res_id];

    ps_mb_params = (dec_mb_info_t *) pv_mb_params;
    ps_svc_mb_params = (dec_svc_mb_info_t *) pv_svc_mb_params;
    ps_motion_pred = ps_ctxt->ps_motion_pred_struct;

    i4_listx = ps_ctxt->i4_listx;

    /* derive the MB_X and MB_Y for the current MB */
    i4_mb_x = ps_mb_params->u2_mbx;
    i4_mb_y = ps_mb_params->u2_mby;

    /* convert into picture units */
    i4_mb_pic_x = i4_mb_x << 4;
    i4_mb_pic_y = i4_mb_y << 4;

    /* compute the motion vectors and reference indices of all part */
    for(i4_blk_y = 0; i4_blk_y < NUM_SUB_MB_PARTS; i4_blk_y++)
    {
        for(i4_blk_x = 0; i4_blk_x < NUM_SUB_MB_PARTS; i4_blk_x++)
        {
            isvcd_interlyr_motion_scale(pv_comp_mode_mv_ctxt, &ai4_ref_part_idc[i4_blk_y][i4_blk_x],
                                        ps_mb_params, (ps_motion_pred + (4 * i4_blk_y) + i4_blk_x),
                                        i4_listx, (i4_mb_pic_x + (i4_blk_x << 2) + 1),
                                        (i4_mb_pic_y + (i4_blk_y << 2) + 1),
                                        ps_dec->ppv_map_ref_idx_to_poc);

        } /* end of blk x loop */
    }     /* end of blk y loop */

    /********************************************************/
    /* get the final reference index into a temparory array */
    /********************************************************/

    /* set reference indices */
    for(i4_i = 0; i4_i < i4_listx; i4_i++)
    {
        ai4_temp_ref_indx[i4_i][0] = ps_motion_pred[0].i1_ref_frame[i4_i];
        ai4_temp_ref_indx[i4_i][1] = ps_motion_pred[2].i1_ref_frame[i4_i];
        ai4_temp_ref_indx[i4_i][2] = ps_motion_pred[8].i1_ref_frame[i4_i];
        ai4_temp_ref_indx[i4_i][3] = ps_motion_pred[10].i1_ref_frame[i4_i];

    } /* end of loop over lists */

    /* if restricted spatial resolution change is not set */
    if(SVCD_FALSE == ps_lyr_mem->ps_curr_lyr_res_prms->u1_rstrct_res_change_flag)
    {
        WORD32 i4_xp, i4_yp;
        WORD32 i4_xs, i4_ys;

        /* merge reference indices and modify the motion vectors */
        for(i4_i = 0; i4_i < i4_listx; i4_i++)
        {
            for(i4_yp = 0; i4_yp < 2; i4_yp++)
            {
                for(i4_xp = 0; i4_xp < 2; i4_xp++)
                {
                    /* get the minimum positive of the refernce index */
                    for(i4_ys = 0; i4_ys < 2; i4_ys++)
                    {
                        for(i4_xs = 0; i4_xs < 2; i4_xs++)
                        {
                            mv_pred_t *ps_temp;
                            ps_temp = ps_motion_pred + (i4_xp << 1) + i4_xs;
                            ps_temp += 4 * ((i4_yp << 1) + i4_ys);

                            /* get the minimum positive */
                            ai4_temp_ref_indx[i4_i][2 * i4_yp + i4_xp] =
                                isvcd_get_min_positive(ai4_temp_ref_indx[i4_i][2 * i4_yp + i4_xp],
                                                       ps_temp->i1_ref_frame[i4_i]);
                        }
                    }
                    /* update motion vectors */
                    for(i4_ys = 0; i4_ys < 2; i4_ys++)
                    {
                        for(i4_xs = 0; i4_xs < 2; i4_xs++)
                        {
                            mv_pred_t *ps_temp;
                            ps_temp = ps_motion_pred + (i4_xp << 1) + i4_xs;
                            ps_temp += 4 * ((i4_yp << 1) + i4_ys);

                            /* check if the current part reference index is */
                            /* not choosen as the final reference index */
                            /* if not copy the neighbours MV */
                            if(ai4_temp_ref_indx[i4_i][2 * i4_yp + i4_xp] !=
                               ps_temp->i1_ref_frame[i4_i])
                            {
                                mv_pred_t *ps_temp_1;
                                WORD32 i4_updated_flag = SVCD_FALSE;

                                ps_temp_1 = ps_motion_pred + (i4_xp << 1) + (1 - i4_xs);
                                ps_temp_1 += 4 * ((i4_yp << 1) + i4_ys);

                                /* store the appropriate neighbours */
                                if(ai4_temp_ref_indx[i4_i][2 * i4_yp + i4_xp] ==
                                   ps_temp_1->i1_ref_frame[i4_i])
                                {
                                    ps_temp->i2_mv[2 * i4_i] = ps_temp_1->i2_mv[2 * i4_i];

                                    ps_temp->i2_mv[1 + (2 * i4_i)] =
                                        ps_temp_1->i2_mv[1 + (2 * i4_i)];
                                    i4_updated_flag = SVCD_TRUE;
                                }

                                if(SVCD_FALSE == i4_updated_flag)
                                {
                                    ps_temp_1 = ps_motion_pred + (i4_xp << 1) + i4_xs;

                                    ps_temp_1 += 4 * ((i4_yp << 1) + 1 - i4_ys);

                                    if(ai4_temp_ref_indx[i4_i][2 * i4_yp + i4_xp] ==
                                       ps_temp_1->i1_ref_frame[i4_i])
                                    {
                                        ps_temp->i2_mv[2 * i4_i] = ps_temp_1->i2_mv[2 * i4_i];

                                        ps_temp->i2_mv[1 + (2 * i4_i)] =
                                            ps_temp_1->i2_mv[1 + (2 * i4_i)];
                                        i4_updated_flag = SVCD_TRUE;
                                    }
                                }
                                if(SVCD_FALSE == i4_updated_flag)
                                {
                                    ps_temp_1 = ps_motion_pred + (i4_xp << 1) + (1 - i4_xs);
                                    ps_temp_1 += 4 * ((i4_yp << 1) + 1 - i4_ys);

                                    ps_temp->i2_mv[2 * i4_i] = ps_temp_1->i2_mv[2 * i4_i];

                                    ps_temp->i2_mv[1 + (2 * i4_i)] =
                                        ps_temp_1->i2_mv[1 + (2 * i4_i)];

                                    i4_updated_flag = SVCD_TRUE;
                                }
                            } /* end of replacement of mv based on ref indx */
                        }     /* end of loop over sub partition xs */
                    }         /* end of loop over sub partition ys */
                }             /* end of loop over partition xp */
            }                 /* end of loop over partition yp */
        }                     /* end of loop over lists */
    }

    /************************************************************************/
    /* if restircted saptial resolution change flag is 0                    */
    /* modify the reference indixes and motion vectors                      */
    /************************************************************************/
    if((SVCD_FALSE == ps_lyr_mem->ps_curr_lyr_res_prms->u1_rstrct_res_change_flag) &&
       (2 == i4_listx) && (SVCD_TRUE == ps_ctxt->u1_direct_8x8_inference_flag))
    {
        /* only applicable for EB Slice */
        /* store the corner 4x4 motion vectors to the whole block */
        /* 2 lists and 4 partitions */
        mot_vec_t s_temp_mv[2][4];
        WORD32 i4_xp, i4_yp;
        memset(&s_temp_mv[0][0], 0, sizeof(s_temp_mv));

        for(i4_i = 0; i4_i < i4_listx; i4_i++)
        {
            s_temp_mv[i4_i][0].i2_mv_x = ps_motion_pred[0].i2_mv[2 * i4_i];
            s_temp_mv[i4_i][0].i2_mv_y = ps_motion_pred[0].i2_mv[1 + (2 * i4_i)];

            s_temp_mv[i4_i][1].i2_mv_x = ps_motion_pred[3].i2_mv[2 * i4_i];
            s_temp_mv[i4_i][1].i2_mv_y = ps_motion_pred[3].i2_mv[1 + (2 * i4_i)];

            s_temp_mv[i4_i][2].i2_mv_x = ps_motion_pred[12].i2_mv[2 * i4_i];
            s_temp_mv[i4_i][2].i2_mv_y = ps_motion_pred[12].i2_mv[1 + (2 * i4_i)];

            s_temp_mv[i4_i][3].i2_mv_x = ps_motion_pred[15].i2_mv[2 * i4_i];
            s_temp_mv[i4_i][3].i2_mv_y = ps_motion_pred[15].i2_mv[1 + (2 * i4_i)];

        } /* end of loop over lists */

        /* replace the motion vectors */
        for(i4_i = 0; i4_i < i4_listx; i4_i++)
        {
            for(i4_yp = 0; i4_yp < 4; i4_yp++)
            {
                for(i4_xp = 0; i4_xp < 4; i4_xp++)
                {
                    mv_pred_t *ps_temp;
                    ps_temp = ps_motion_pred + i4_xp;
                    ps_temp += 4 * i4_yp;

                    ps_temp->i2_mv[2 * i4_i] =
                        s_temp_mv[i4_i][2 * (i4_yp >> 1) + (i4_xp >> 1)].i2_mv_x;

                    ps_temp->i2_mv[1 + (2 * i4_i)] =
                        s_temp_mv[i4_i][2 * (i4_yp >> 1) + (i4_xp >> 1)].i2_mv_y;

                } /* end of loop over sub partitions xp */
            }     /* end of loop over sub partitions yp */
        }         /* end of loop over lists */
    }

    /* store the final reference index for all sub partitions */
    /* approporiate reference index is stored for each 4x4 belonging to 8x8 */
    {
        WORD32 i4_xp, i4_yp;

        for(i4_i = 0; i4_i < i4_listx; i4_i++)
        {
            for(i4_yp = 0; i4_yp < 4; i4_yp++)
            {
                for(i4_xp = 0; i4_xp < 4; i4_xp++)
                {
                    mv_pred_t *ps_temp;
                    ps_temp = ps_motion_pred + i4_xp;
                    ps_temp += 4 * i4_yp;

                    ps_temp->i1_ref_frame[i4_i] =
                        ai4_temp_ref_indx[i4_i][2 * (i4_yp >> 1) + (i4_xp >> 1)];

                } /* end of loop over partition xp */
            }     /* end of loop over partition yp */
        }         /* end of loop over lists */
    }

    /********************************************************************/
    /* modify the motion vectors for non dyadic cases, set the mv       */
    /* threshold appropraitely to derive the sub MB type                */
    /********************************************************************/
    if(SVCD_FALSE == ps_lyr_mem->ps_curr_lyr_res_prms->u1_rstrct_res_change_flag)
    {
        /* non dyadic cases set the mv treshold to 1 */
        i4_mv_treshold = 1;
    }
    else
    {
        /* dyadic cases set the mv treshold to 0 */
        i4_mv_treshold = 0;
    }

    /* modify the motion vectors and get sub mb mode if base mode flag is 1 */
    if((SVCD_FALSE == ps_lyr_mem->ps_curr_lyr_res_prms->u1_rstrct_res_change_flag) ||
       (1 == ps_svc_mb_params->u1_base_mode_flag))
    {
        WORD32 i4_xp, i4_yp;
        for(i4_yp = 0; i4_yp < 2; i4_yp++)
        {
            for(i4_xp = 0; i4_xp < 2; i4_xp++)
            {
                mv_pred_t *ps_temp;
                WORD32 i4_part_size = 0;
                WORD32 i4_horz1_match, i4_vert1_match;
                WORD32 i4_horz2_match, i4_vert2_match;
                WORD32 i4_diag_match;

                WORD32 i4_8x8_match, i4_horz_match, i4_vert_match;
                WORD32 i4_mv_x, i4_mv_y;

                ps_temp = ps_motion_pred + (i4_xp << 1);
                ps_temp += 4 * ((i4_yp << 1));

                /* default init */
                i4_8x8_match = i4_horz_match = i4_vert_match = SVCD_TRUE;

                /* check if the mv diff in horz direction is under threshold*/
                i4_horz1_match =
                    isvcd_check_mv_diff(ps_temp, (ps_temp + 1), i4_listx, i4_mv_treshold);

                i4_horz2_match =
                    isvcd_check_mv_diff((ps_temp + 4), (ps_temp + 4 + 1), i4_listx, i4_mv_treshold);

                /* check if the mv diff in horz direction is under threshold*/
                i4_vert1_match =
                    isvcd_check_mv_diff(ps_temp, (ps_temp + 4), i4_listx, i4_mv_treshold);

                i4_vert2_match =
                    isvcd_check_mv_diff((ps_temp + 1), (ps_temp + 4 + 1), i4_listx, i4_mv_treshold);

                /* check if in diagonal direction is under threshold*/
                i4_diag_match =
                    isvcd_check_mv_diff(ps_temp, (ps_temp + 4 + 1), i4_listx, i4_mv_treshold);

                /* calculate the excat matching points*/
                i4_8x8_match = i4_8x8_match && i4_horz1_match && i4_vert1_match && i4_diag_match;
                i4_horz_match = i4_horz_match && i4_horz1_match && i4_horz2_match;
                i4_vert_match = i4_vert_match && i4_vert1_match && i4_vert2_match;

                /* modify the motion vectors appropriately */

                for(i4_i = 0; i4_i < i4_listx; i4_i++)
                {
                    /* 8x8 mode all the 4 blocks are under threshold */
                    if(SVCD_TRUE == i4_8x8_match)
                    {
                        /* calculate the avarage */
                        i4_mv_x =
                            ((ps_temp[0].i2_mv[2 * i4_i]) + (ps_temp[1].i2_mv[2 * i4_i]) +
                             (ps_temp[4].i2_mv[2 * i4_i]) + (ps_temp[5].i2_mv[2 * i4_i] + 2)) >>
                            2;

                        i4_mv_y = ((ps_temp[0].i2_mv[1 + (2 * i4_i)]) +
                                   (ps_temp[1].i2_mv[1 + (2 * i4_i)]) +
                                   (ps_temp[4].i2_mv[1 + (2 * i4_i)]) +
                                   (ps_temp[5].i2_mv[1 + (2 * i4_i)] + 2)) >>
                                  2;

                        /* store the modified motion vectors */
                        ps_temp[0].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;
                        ps_temp[1].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;
                        ps_temp[4].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;
                        ps_temp[5].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;

                        ps_temp[0].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        ps_temp[1].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        ps_temp[4].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        ps_temp[5].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;

                        /* store the sub mb partition size */
                        i4_part_size = SUBMB_8x8;
                    }
                    /* 8x4 mode  */
                    else if(SVCD_TRUE == i4_horz_match)
                    {
                        /* horizontal directional merging */
                        /* calculate the average of first two and store back*/
                        i4_mv_x =
                            ((ps_temp[0].i2_mv[2 * i4_i]) + (ps_temp[1].i2_mv[2 * i4_i] + 1)) >> 1;

                        i4_mv_y = ((ps_temp[0].i2_mv[1 + (2 * i4_i)]) +
                                   (ps_temp[1].i2_mv[1 + (2 * i4_i)] + 1)) >>
                                  1;

                        ps_temp[0].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;
                        ps_temp[1].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;

                        ps_temp[0].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        ps_temp[1].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;

                        /* calculate the average of next two and store back*/
                        i4_mv_x =
                            ((ps_temp[4].i2_mv[2 * i4_i]) + (ps_temp[5].i2_mv[2 * i4_i] + 1)) >> 1;

                        i4_mv_y = ((ps_temp[4].i2_mv[1 + (2 * i4_i)]) +
                                   (ps_temp[5].i2_mv[1 + (2 * i4_i)] + 1)) >>
                                  1;

                        ps_temp[4].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;
                        ps_temp[5].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;

                        ps_temp[4].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        ps_temp[5].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        /* store the sub mb partition size */
                        i4_part_size = SUBMB_8x4;
                    }
                    /* 4x8 mode all the 4 blocks are under threshold */
                    else if(SVCD_TRUE == i4_vert_match)
                    {
                        /* vertical directional merging */
                        i4_mv_x =
                            ((ps_temp[0].i2_mv[2 * i4_i]) + (ps_temp[4].i2_mv[2 * i4_i] + 1)) >> 1;

                        i4_mv_y = ((ps_temp[0].i2_mv[1 + (2 * i4_i)]) +
                                   (ps_temp[4].i2_mv[1 + (2 * i4_i)] + 1)) >>
                                  1;

                        ps_temp[0].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;
                        ps_temp[4].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;

                        ps_temp[0].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        ps_temp[4].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;

                        /* calculate the average of next two and store back*/
                        i4_mv_x =
                            ((ps_temp[1].i2_mv[2 * i4_i]) + (ps_temp[5].i2_mv[2 * i4_i] + 1)) >> 1;

                        i4_mv_y = ((ps_temp[1].i2_mv[1 + (2 * i4_i)]) +
                                   (ps_temp[5].i2_mv[1 + (2 * i4_i)] + 1)) >>
                                  1;

                        ps_temp[1].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;
                        ps_temp[5].i2_mv[2 * i4_i] = (WORD16) i4_mv_x;

                        ps_temp[1].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        ps_temp[5].i2_mv[1 + (2 * i4_i)] = (WORD16) i4_mv_y;
                        /* store the sub mb partition size */
                        i4_part_size = SUBMB_4x8;
                    }
                    else
                    {
                        /* store the sub mb partition size */
                        i4_part_size = SUBMB_4x4;
                    }

                } /* end of loop over lists */

                /* store the sub MB type B slice */
                if(2 == i4_listx)
                {
                    WORD32 i4_part_mode_a;
                    WORD32 i4_indx;

                    i4_part_mode_a = 0;
                    /* check the 0th partiton reference indices */
                    if(0 <= ps_temp[0].i1_ref_frame[0])
                    {
                        i4_part_mode_a += 1;
                    }
                    if(0 <= ps_temp[0].i1_ref_frame[1])
                    {
                        i4_part_mode_a += 2;
                    }
                    i4_indx = 3 * i4_part_size + (i4_part_mode_a - 1);

                    pi4_sub_mb_mode[2 * i4_yp + i4_xp] = g_au1_eb_submb_type[i4_indx];
                }
                /* P slice */
                else
                {
                    pi4_sub_mb_mode[2 * i4_yp + i4_xp] = g_au1_ep_submb_type[i4_part_size];
                }
            } /* end of loop over partition xp */

        }     /* end of loop over partition yp */
    }

    return;
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_interlyr_mbmode_pred_bmb                          */
/*                                                                           */
/*  Description   : this module does the mode predcition for base mode B_MB  */
/*                                                                           */
/*                                                                           */
/*  Inputs        : pv_comp_mode_mv_ctxt : motion mode hanldle               */
/*  Globals       : none                                                     */
/*  Processing    : it checks the sub MB type derived motion prediction. if  */
/*                  all partitions are 8x8 then it goes further matching     */
/*                  finally it stores the MB type using a look up table      */
/*  Outputs       : none                                                     */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
void isvcd_interlyr_mbmode_pred_bmb(mode_motion_ctxt_t *ps_ctxt, mv_pred_t *ps_motion_pred,
                                    WORD32 i4_cur_mot_stride, WORD32 i4_part_size,
                                    WORD32 *pi4_sub_mb_mode, void *pv_mb_params, void *pv_part,
                                    UWORD8 *pu1_col_info)
{
    WORD32 i4_part_mode_a, i4_part_mode_b;
    WORD32 i4_idx;
    dec_mb_info_t *ps_mb_params = (dec_mb_info_t *) pv_mb_params;
    parse_part_params_t *ps_part = (parse_part_params_t *) pv_part;

    UNUSED(ps_ctxt);

    i4_part_mode_a = 0;

    /* check the 0th partiton reference indices */
    if(PRED_8x8 != i4_part_size)
    {
        if(0 <= ps_motion_pred[0].i1_ref_frame[0])
        {
            i4_part_mode_a += 1;
        }
        if(0 <= ps_motion_pred[0].i1_ref_frame[1])
        {
            i4_part_mode_a += 2;
        }
    }

    /* check the 15th partiton reference indices */
    /* this done since all the reference indices will be replicated */
    i4_part_mode_b = 0;

    if((PRED_16x8 == i4_part_size) || (PRED_8x16 == i4_part_size))
    {
        ps_motion_pred += (3 * i4_cur_mot_stride) + 3;

        if(0 <= ps_motion_pred[0].i1_ref_frame[0])
        {
            i4_part_mode_b += 1;
        }
        if(0 <= ps_motion_pred[0].i1_ref_frame[1])
        {
            i4_part_mode_b += 2;
        }
    }
    /* update the pred modes for B cases */
    /* If partition size is not equal to 8x8 */
    /* then update the prediciton mode of    */
    /* partitions                            */
    if(PRED_8x8 != i4_part_size)
    {
        UWORD8 u1_pred_mode_part0;
        UWORD8 u1_pred_mode_part1;

        i4_idx = 3 * i4_part_size;
        i4_idx += 3 * (i4_part_mode_a - 1);
        i4_part_mode_b = (i4_part_mode_b > 0) ? i4_part_mode_b : 1;
        i4_idx += (i4_part_mode_b - 1);
        i4_idx = (i4_idx < 0) ? 0 : i4_idx;
        /* Get the mb type                     */
        /* From mb type - get prediciton modes */
        /*  of parttions                       */
        /* Update the prediciton mode parma of */
        /* mb param structure                  */

        ps_mb_params->u1_mb_type = g_au1_eb_mb_type[i4_idx + (6 * i4_part_size)];
        u1_pred_mode_part0 = g_au1_mb_pred_mode[0][5 + ps_mb_params->u1_mb_type];
        u1_pred_mode_part1 = g_au1_mb_pred_mode[1][5 + ps_mb_params->u1_mb_type];
        ps_part[0].u1_pred_mode = u1_pred_mode_part0;
        ps_part[1].u1_pred_mode = u1_pred_mode_part1;
    }
    else
    {
        WORD32 i4_i, i4_ctr, i4_num_submb_part;
        UWORD8 u1_sub_mb_type, u1_sub_mb_mc_mode;
        UWORD8 u1_pred_mode;

        ps_mb_params->u1_mb_type = B_8x8;

        for(i4_i = 0; i4_i < NUM_MB_PARTS; i4_i++)
        {
            u1_sub_mb_type = (UWORD8) pi4_sub_mb_mode[i4_i];

            u1_sub_mb_mc_mode = gau1_ih264d_submb_mc_mode[4 + u1_sub_mb_type];
            i4_num_submb_part = g_au1_num_sub_mb_part[u1_sub_mb_mc_mode];
            *pu1_col_info |= (u1_sub_mb_mc_mode << 4);
            pu1_col_info++;
            u1_pred_mode = g_au1_sub_mb_pred_mode[4 + u1_sub_mb_type];
            for(i4_ctr = 0; i4_ctr < i4_num_submb_part; i4_ctr++)
            {
                ps_part->u1_pred_mode = u1_pred_mode;
                ps_part++;
            }
        }
    }

    return;
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_populate_ref_idx                                    */
/*                                                                           */
/*  Description   : this module populates the reference idx based on the     */
/*                  motion prediction flags                                  */
/*                                                                           */
/*  Inputs        :                                                          */
/*  Globals       : none                                                     */
/*  Processing    :                                                          */
/*  Outputs       : none                                                     */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/

void isvcd_populate_ref_idx(dec_mb_info_t *ps_mb_params, dec_svc_mb_info_t *ps_svc_mb_params,
                            mv_pred_t *ps_motion_pred, parse_pmbarams_t *ps_mb_part_info,
                            WORD32 i4_listx)
{
    UWORD8 u1_mot_pred_flag;
    WORD32 i4_lx;

    for(i4_lx = 0; i4_lx < i4_listx; i4_lx++)
    {
        u1_mot_pred_flag = ps_svc_mb_params->au1_motion_pred_flag[i4_lx];

        if((PRED_16x16 == ps_mb_params->u1_mb_mc_mode) && (u1_mot_pred_flag & 0x1))
        {
            ps_mb_part_info->i1_ref_idx[i4_lx][0] = ps_motion_pred[0].i1_ref_frame[i4_lx];
        }
        else if((PRED_8x16 == ps_mb_params->u1_mb_mc_mode))
        {
            if(u1_mot_pred_flag & 0x01)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][0] = ps_motion_pred[0].i1_ref_frame[i4_lx];
            }
            if(u1_mot_pred_flag & 0x02)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][1] = ps_motion_pred[2].i1_ref_frame[i4_lx];
            }
        }
        else if((PRED_16x8 == ps_mb_params->u1_mb_mc_mode))
        {
            if(u1_mot_pred_flag & 0x01)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][0] = ps_motion_pred[0].i1_ref_frame[i4_lx];
            }
            if(u1_mot_pred_flag & 0x02)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][1] = ps_motion_pred[8].i1_ref_frame[i4_lx];
            }
        }
        else if((PRED_8x8 == ps_mb_params->u1_mb_mc_mode))
        {
            if(u1_mot_pred_flag & 0x01)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][0] = ps_motion_pred[0].i1_ref_frame[i4_lx];
            }
            if(u1_mot_pred_flag & 0x02)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][1] = ps_motion_pred[2].i1_ref_frame[i4_lx];
            }
            if(u1_mot_pred_flag & 0x04)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][2] = ps_motion_pred[8].i1_ref_frame[i4_lx];
            }
            if(u1_mot_pred_flag & 0x08)
            {
                ps_mb_part_info->i1_ref_idx[i4_lx][3] = ps_motion_pred[10].i1_ref_frame[i4_lx];
            }
        }
    }
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name : svcd_interlayer_mbmode_pred                              */
/*                                                                           */
/*  Description   : this module does the mode predcition for base mode MB    */
/*                                                                           */
/*                                                                           */
/*  Inputs        : pv_comp_mode_mv_ctxt : motion mode hanldle               */
/*                  pv_mb_params   : pointer to MB params structure          */
/*                  pi4_sub_mb_mode: pointer to sub mbmodes predicted        */
/*  Globals       : none                                                     */
/*  Processing    : it checks the sub MB type derived motion prediction. if  */
/*                  all partitions are 8x8 then it goes further matching     */
/*                  finally it stores the MB type using a look up table      */
/*  Outputs       : none                                                     */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
void isvcd_interlyr_mbmode_pred(void *pv_comp_mode_mv_ctxt, void *pv_mb_params,
                                WORD32 *pi4_sub_mb_mode, WORD32 *pi4_mb_mode, void *pv_dec,
                                void *pv_mb_part_info, void *pv_part)
{
    /*! Flow of the module is as follows                                   */
    /*! 1. it checks if all the sub mb modes are 8x8 modes                 */
    /*! 2. it matches the motion vectors at 8x8 level and computes the
           partiton size. store the same in the part type of mb params     */
    /*! 3. stores the pred modes based on slcie type and reference indices */
    /*! 4. stores the sub mb type in the mb params if teh part size is 8x8 */
    mode_motion_ctxt_t *ps_ctxt;
    mv_pred_t *ps_motion_pred;
    dec_mb_info_t *ps_mb_params;
    WORD32 i4_listx;
    WORD32 i4_part_size;
    WORD32 i4_mb_mode_flag;
    WORD32 i4_i;
    WORD32 i4_blk_mode;
    parse_part_params_t *ps_part = (parse_part_params_t *) pv_part;
    parse_pmbarams_t *ps_mb_part_info = (parse_pmbarams_t *) pv_mb_part_info;
    UWORD8 *pu1_col_info = ps_mb_part_info->u1_col_info;
    UNUSED(pv_dec);

    ps_ctxt = (mode_motion_ctxt_t *) pv_comp_mode_mv_ctxt;
    ps_motion_pred = ps_ctxt->ps_motion_pred_struct;
    ps_mb_params = (dec_mb_info_t *) pv_mb_params;

    /*********** store the MB mode as inter *************************/
    *pi4_mb_mode = SVC_INTER_MB;

    /***********************************************************************/
    /* derivation of part type                                             */
    /***********************************************************************/
    i4_listx = ps_ctxt->i4_listx;

    /* set the mb mode derivation flag to false */
    i4_mb_mode_flag = SVCD_FALSE;

    /* for B and P slice different blk mod treshold */
    if(2 == i4_listx)
    {
        i4_blk_mode = B_BI_8x8;
    }
    else
    {
        i4_blk_mode = P_L0_8x8;
    }

    /* set the mode derivation flag to true base on conditions */
    if((i4_blk_mode >= pi4_sub_mb_mode[0]) && (i4_blk_mode >= pi4_sub_mb_mode[1]) &&
       (i4_blk_mode >= pi4_sub_mb_mode[2]) && (i4_blk_mode >= pi4_sub_mb_mode[3]))
    {
        i4_mb_mode_flag = SVCD_TRUE;
    }

    /* store the default 8x8 mode */
    ps_mb_part_info->u1_num_part = 4;
    i4_part_size = PRED_8x8;

    /* further check is present if all are 8x8 mode */
    if(SVCD_TRUE == i4_mb_mode_flag)
    {
        WORD32 i4_horz_match, i4_vert_match;

        /* check if the motion in horz direction are same*/
        i4_horz_match = isvcd_check_motion(ps_motion_pred, (ps_motion_pred + 2), i4_listx);
        i4_horz_match += isvcd_check_motion((ps_motion_pred + 8), (ps_motion_pred + 10), i4_listx);

        /* check if the motion in vertical direction is same */
        i4_vert_match = isvcd_check_motion(ps_motion_pred, (ps_motion_pred + 8), i4_listx);
        i4_vert_match += isvcd_check_motion((ps_motion_pred + 2), (ps_motion_pred + 10), i4_listx);

        /* decide the partition size based on the results of matching */
        if((2 == i4_horz_match) && (2 == i4_vert_match))
        {
            ps_mb_params->u1_mb_type = P_L0_16x16;
            i4_part_size = PRED_16x16;
            ps_mb_part_info->u1_num_part = 1;
            *pu1_col_info++ = (PRED_16x16 << 6);
            ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred->i1_ref_frame[0];
            if(2 == i4_listx) ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred->i1_ref_frame[1];

            ps_part->u1_partwidth = 4;  // interms of 4x4
            ps_part->u1_partheight = 4;
            ps_part->u1_pred_mode = PRED_L0;
            ps_part->u1_is_direct = 0;
            ps_part->u1_sub_mb_num = 0;
        }
        else if(2 == i4_horz_match)
        {
            i4_part_size = PRED_16x8;
            ps_mb_params->u1_mb_type = P_L0_L0_16x8;
            ps_mb_part_info->u1_num_part = 2;
            *pu1_col_info++ = (PRED_16x8 << 6);
            *pu1_col_info++ = (PRED_16x8 << 6);

            ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred->i1_ref_frame[0];
            ps_mb_part_info->i1_ref_idx[0][1] = ps_motion_pred[8].i1_ref_frame[0];
            if(2 == i4_listx)
            {
                ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred->i1_ref_frame[1];
                ps_mb_part_info->i1_ref_idx[1][1] = ps_motion_pred[8].i1_ref_frame[1];
            }
            ps_part->u1_partwidth = 4;  // interms of 4x4
            ps_part->u1_partheight = 2;
            ps_part->u1_pred_mode = PRED_L0;
            ps_part->u1_is_direct = 0;
            ps_part->u1_sub_mb_num = 0;

            ps_part++;
            ps_part->u1_partwidth = 4;
            ps_part->u1_partheight = 2;
            ps_part->u1_pred_mode = PRED_L0;
            ps_part->u1_is_direct = 0;
            ps_part->u1_sub_mb_num = 8;
        }
        else if(2 == i4_vert_match)
        {
            ps_mb_params->u1_mb_type = P_L0_L0_8x16;
            i4_part_size = PRED_8x16;
            ps_mb_part_info->u1_num_part = 2;
            *pu1_col_info++ = (PRED_8x16 << 6);
            *pu1_col_info++ = (PRED_8x16 << 6);

            ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred->i1_ref_frame[0];
            ps_mb_part_info->i1_ref_idx[0][1] = ps_motion_pred[2].i1_ref_frame[0];
            if(2 == i4_listx)
            {
                ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred->i1_ref_frame[1];
                ps_mb_part_info->i1_ref_idx[1][1] = ps_motion_pred[2].i1_ref_frame[1];
            }
            ps_part->u1_partwidth = 2;  // interms of 4x4
            ps_part->u1_partheight = 4;
            ps_part->u1_pred_mode = PRED_L0;
            ps_part->u1_is_direct = 0;
            ps_part->u1_sub_mb_num = 0;

            ps_part++;
            ps_part->u1_partwidth = 2;
            ps_part->u1_partheight = 4;
            ps_part->u1_pred_mode = PRED_L0;
            ps_part->u1_is_direct = 0;
            ps_part->u1_sub_mb_num = 2;
        }
    }

    /* store the part size to the mb params */
    ps_mb_params->u1_mb_mc_mode = i4_part_size;

    /* in case of slice derive the partition modes */

    {
        /* store the sub MB modes if 8x8 mode is choosen */
        if(PRED_8x8 == i4_part_size)
        {
            UWORD8 u1_sub_mb_type, u1_sub_mb_mc_mode = 0;

            /* for P_MB sub part type is same as sub mb type */
            ps_mb_params->u1_mb_type = P_8x8;
            ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred[0].i1_ref_frame[0];
            ps_mb_part_info->i1_ref_idx[0][1] = ps_motion_pred[2].i1_ref_frame[0];
            ps_mb_part_info->i1_ref_idx[0][2] = ps_motion_pred[8].i1_ref_frame[0];
            ps_mb_part_info->i1_ref_idx[0][3] = ps_motion_pred[10].i1_ref_frame[0];
            if(2 == i4_listx)
            {
                ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred[0].i1_ref_frame[1];
                ps_mb_part_info->i1_ref_idx[1][1] = ps_motion_pred[2].i1_ref_frame[1];
                ps_mb_part_info->i1_ref_idx[1][2] = ps_motion_pred[8].i1_ref_frame[1];
                ps_mb_part_info->i1_ref_idx[1][3] = ps_motion_pred[10].i1_ref_frame[1];
            }

            ps_mb_part_info->u1_num_part = 0;
            for(i4_i = 0; i4_i < NUM_MB_PARTS; i4_i++)
            {
                WORD32 i4_num_submb_part, i4_part_width, i4_part_height, i4_ctr;
                u1_sub_mb_type = (UWORD8) pi4_sub_mb_mode[i4_i];

                if(1 == i4_listx)
                {
                    u1_sub_mb_mc_mode = gau1_ih264d_submb_mc_mode[u1_sub_mb_type];
                }
                else if(2 == i4_listx)
                {
                    u1_sub_mb_mc_mode = gau1_ih264d_submb_mc_mode[4 + u1_sub_mb_type];
                }
                i4_num_submb_part = g_au1_num_sub_mb_part[u1_sub_mb_mc_mode];

                ps_mb_part_info->u1_num_part += i4_num_submb_part;

                i4_part_width = g_au1_sub_mb_part_wd[u1_sub_mb_mc_mode];
                i4_part_height = g_au1_sub_mb_part_ht[u1_sub_mb_mc_mode];
                *pu1_col_info++ = (PRED_8x8 << 6) | (u1_sub_mb_mc_mode << 4);
                for(i4_ctr = 0; i4_ctr < i4_num_submb_part; i4_ctr++)
                {
                    ps_part->u1_partwidth = i4_part_width;  // interms of 4x4
                    ps_part->u1_partheight = i4_part_height;
                    ps_part->u1_pred_mode = PRED_L0;
                    ps_part->u1_is_direct = 0;
                    ps_part->u1_sub_mb_num = (i4_i & 0x01) * 2 + (i4_i >> 1) * 8;
                    if(i4_num_submb_part == 2)
                    {
                        ps_part->u1_sub_mb_num +=
                            i4_ctr ? (((i4_part_width - 1) << 2) + (i4_part_height - 1)) : 0;
                    }
                    else if(i4_num_submb_part == 4)
                    {
                        ps_part->u1_sub_mb_num += ((i4_ctr >> 1) << 2) + (i4_ctr & 0x01);
                    }

                    ps_part++;
                }
            }
        }
        if(2 == i4_listx)
        {
            ps_part = (parse_part_params_t *) pv_part;
            pu1_col_info = ps_mb_part_info->u1_col_info;
            /* B_MBs */
            isvcd_interlyr_mbmode_pred_bmb(ps_ctxt, ps_motion_pred, 4, i4_part_size,
                                           pi4_sub_mb_mode, ps_mb_params, ps_part, pu1_col_info);
        }
    }

    return;
}
/*****************************************************************************/
/*                                                                           */
/*  Function Name :  isvcd_compute_interlayer_motion_mode                     */
/*                                                                           */
/*  Description   : this function does the  inter layer motion and mode      */
/*                  prediction. of the current MB                            */
/*                                                                           */
/*  Inputs        : pv_comp_mode_mv_ctxt : mode motion handle                */
/*                  pv_ref_layer_motion_mem_elements :  pointer to memory    */
/*                    elements of reference layer motion params              */
/*                  pv_mb_params : pointer to mb params structure            */
/*  Globals       : none                                                     */
/*  Processing    : it calls the module for cal ref part idc and intra flag  */
/*                  if not intra it calls the motion prediction module       */
/*                  if base mdoe flag then it call teh mode prediction module*/
/*  Outputs       : inter layer predicted parameters                         */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_compute_interlyr_motion_mode(void *pv_comp_mode_mv_ctxt, void *pv_mb_params,
                                          void *pv_svc_mb_params, void *pv_dec,
                                          void *pv_mb_part_info, void *pv_part)
{
    /*! Flow of the module is as follows                                   */
    /*! 1. if dyaydic case then it sets the sub mb mode to 8x8             */
    /*! 2. else it call the ref part idc comute fucntion                   */
    /*! 3. it calls the motion vectors and submb mode derive function.
           if the current mb is not inffered as INTRA                      */
    /*! 4. it calls the mode predcition module if base mode flag is 1      */

    mode_motion_ctxt_t *ps_ctxt;
    WORD32 i4_intra_flag;
    WORD32 ai4_sub_mb_mode[NUM_MB_PARTS] = {0};
    dec_mb_info_t *ps_mb_params;
    dec_svc_mb_info_t *ps_svc_mb_params;
    dec_struct_t *ps_dec = (dec_struct_t *) pv_dec;
    WORD32 i4_mb_mode = -1;
    parse_pmbarams_t *ps_mb_part_info = (parse_pmbarams_t *) pv_mb_part_info;
    parse_part_params_t *ps_part = (parse_part_params_t *) pv_part;

    ps_ctxt = (mode_motion_ctxt_t *) pv_comp_mode_mv_ctxt;
    ps_mb_params = (dec_mb_info_t *) pv_mb_params;
    ps_svc_mb_params = (dec_svc_mb_info_t *) pv_svc_mb_params;

    i4_intra_flag = SVCD_FALSE;

    isvcd_ref_lyr_part_idc(pv_comp_mode_mv_ctxt, ps_ctxt->ai4_ref_part_idc, &i4_intra_flag,
                           pv_mb_params);

    /* If base is Intra */
    if(SVCD_TRUE == i4_intra_flag)
    {
        if(1 == ps_svc_mb_params->u1_base_mode_flag)
        {
            i4_mb_mode = SVC_IBL_MB;
            ps_svc_mb_params->u1_residual_prediction_flag = 0;
        }
    }
    else
    {
        /* derive the motion and reference index by inter layer predcition */
        isvcd_interlyr_motion_submbmode_pred(pv_comp_mode_mv_ctxt, ps_mb_params, ps_svc_mb_params,
                                             ps_ctxt->ai4_ref_part_idc, ai4_sub_mb_mode, pv_dec);

        /* derive the MB mode */
        if(1 == ps_svc_mb_params->u1_base_mode_flag)
        {
            isvcd_interlyr_mbmode_pred(pv_comp_mode_mv_ctxt, pv_mb_params, ai4_sub_mb_mode,
                                       &i4_mb_mode, ps_dec, ps_mb_part_info, ps_part);
        }
        else
        {
            isvcd_populate_ref_idx(ps_mb_params, ps_svc_mb_params, ps_ctxt->ps_motion_pred_struct,
                                   ps_mb_part_info, ps_ctxt->i4_listx);
        }
    }

    return i4_mb_mode;
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name :  isvcd_interlyr_motion_mode_pred_dyadic                   */
/*                                                                           */
/*  Description   : this function does the inter layer motion predcition for */
/*                   dyadic cases                                            */
/*                                                                           */
/*  Inputs        : pv_comp_mode_mv_ctxt : motion mode handle                */
/*                  pv_ref_layer_motion_mem_elements : pointer to memory     */
/*                    elements of reference layer motion params              */
/*                  pv_mb_params : pointer to MB params structure            */
/*                  ai4_ref_part_idc : ref partitons idc of all 4x4 blocks   */
/*                  pi4_sub_mb_mode  : pointer to store the sub mb modes     */
/*                  i4_mb_addr       : current mb address                    */
/*                  pi4_intra_flag   : location to store the intra status    */
/*  Globals       : none                                                     */
/*  Processing    : it computes the motion vectors and                       */
/*  Outputs       : inter layer predicted motion vectors and ref indices     */
/*                  sub mbmodes of the 4 mb partitions                       */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_interlyr_motion_mode_pred_dyadic(void *pv_comp_mode_mv_ctxt, void *pv_mb_params,
                                              void *pv_svc_mb_params, void *pv_dec,
                                              void *pv_mb_part_info, void *pv_part)
{
    mode_motion_ctxt_t *ps_ctxt;
    mode_motion_lyr_ctxt *ps_lyr_mem;
    dec_mb_info_t *ps_mb_params;
    dec_svc_mb_info_t *ps_svc_mb_params;
    WORD32 i4_listx;
    WORD32 i4_mb_pic_x, i4_mb_pic_y;
    WORD32 i4_ref_x, i4_ref_y;
    UWORD8 u1_base_mode_flag;
    dec_struct_t *ps_dec = (dec_struct_t *) pv_dec;
    WORD32 i4_mb_mode = -1;
    parse_pmbarams_t *ps_mb_part_info = (parse_pmbarams_t *) pv_mb_part_info;
    UWORD8 *pu1_col_info = ps_mb_part_info->u1_col_info;
    parse_part_params_t *ps_part = (parse_part_params_t *) pv_part;

    ps_ctxt = (mode_motion_ctxt_t *) pv_comp_mode_mv_ctxt;

    /* get the current layer ctxt */
    ps_lyr_mem = &ps_ctxt->as_res_lyr_mem[ps_ctxt->i4_res_id];

    ps_mb_params = (dec_mb_info_t *) pv_mb_params;
    ps_svc_mb_params = (dec_svc_mb_info_t *) pv_svc_mb_params;
    i4_listx = ps_ctxt->i4_listx;

    {
        WORD32 i4_mb_x, i4_mb_y;
        /* derive the MB_X and MB_Y for the current MB */
        i4_mb_x = ps_mb_params->u2_mbx;
        i4_mb_y = ps_mb_params->u2_mby;

        /* get the colocated position in the refernce layer */
        i4_ref_x = ps_lyr_mem->pi2_ref_loc_x[i4_mb_x << 4];
        i4_ref_y = ps_lyr_mem->pi2_ref_loc_y[i4_mb_y << 4];
        i4_ref_x = CLIP3(0, ((ps_lyr_mem->i4_ref_width) - 1), i4_ref_x);
        i4_ref_y = CLIP3(0, ((ps_lyr_mem->i4_ref_height) - 1), i4_ref_y);

        /* convert into picture units */
        i4_mb_pic_x = i4_mb_x << 4;
        i4_mb_pic_y = i4_mb_y << 4;
    }

    /* ref layer mb mode */
    {
        inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms;
        WORD32 i4_inter_lyr_mb_prms_stride;
        WORD32 i4_ref_mb_x, i4_ref_mb_y;
        WORD8 i1_ref_mb_mode;

        ps_inter_lyr_mb_prms = (inter_lyr_mb_prms_t *) ps_lyr_mem->s_ref_mb_mode.pv_buffer;
        i4_inter_lyr_mb_prms_stride = ps_lyr_mem->s_ref_mb_mode.i4_num_element_stride;

        /* get the reference mb x and y */
        i4_ref_mb_x = (i4_ref_x >> 4);
        i4_ref_mb_y = (i4_ref_y >> 4);

        /* get the appropriate mb params in reference layer */
        ps_inter_lyr_mb_prms += i4_ref_mb_x;
        ps_inter_lyr_mb_prms += i4_ref_mb_y * i4_inter_lyr_mb_prms_stride;
        i1_ref_mb_mode = ps_inter_lyr_mb_prms->i1_mb_mode;
        u1_base_mode_flag = ps_svc_mb_params->u1_base_mode_flag;

        /* check if the MB mode of the refernce MB is Intra*/
        if(i1_ref_mb_mode > SVC_INTER_MB)
        {
            if(1 == u1_base_mode_flag)
            {
                i4_mb_mode = SVC_IBL_MB;
                ps_svc_mb_params->u1_residual_prediction_flag = 0;
            }
            return i4_mb_mode;
        }
    }

    /*-----------------------------------------------------------------------*/
    /* Inter MB upsampling process                                           */
    /*-----------------------------------------------------------------------*/
    {
        mv_pred_t *ps_motion_pred;
        WORD32 i4_16x16_flag;
        WORD32 i4_part_idc;
        WORD32 i4_blk_idx;
        WORD32 i4_curr_mot_stride;

        /* choose the appropriate mv bank pointer and stride */
        if(1 == u1_base_mode_flag)
        {
            i4_mb_mode = SVC_INTER_MB;
        }

        ps_motion_pred = ps_ctxt->ps_motion_pred_struct;
        i4_curr_mot_stride = 4;

        /* call the motion upsampling for 1st 4x4 */
        i4_part_idc = (i4_ref_y << 16) + i4_ref_x;
        i4_16x16_flag = isvcd_interlyr_motion_scale(
            pv_comp_mode_mv_ctxt, &i4_part_idc, ps_mb_params, ps_motion_pred, i4_listx,
            (i4_mb_pic_x + 1), (i4_mb_pic_y + 1), ps_dec->ppv_map_ref_idx_to_poc);

        /* ---------- reference layer MB is 16x16 ------------------*/
        if(i4_16x16_flag)
        {
            if(1 == u1_base_mode_flag)
            {
                ps_mb_params->u1_mb_type = P_L0_16x16;
                ps_mb_params->u1_mb_mc_mode = PRED_16x16;
                ps_mb_part_info->u1_num_part = 1;
                *pu1_col_info++ = (PRED_16x16 << 6);
                ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred->i1_ref_frame[0];

                ps_part->u1_partwidth = 4;  // interms of 4x4
                ps_part->u1_partheight = 4;
                ps_part->u1_pred_mode = PRED_L0;
                ps_part->u1_is_direct = 0;
                ps_part->u1_sub_mb_num = 0;

                if(2 == i4_listx)
                {
                    WORD32 i4_part_mode_a = 0;
                    WORD32 i4_temp;

                    ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred->i1_ref_frame[1];
                    if(0 <= ps_motion_pred[0].i1_ref_frame[0])
                    {
                        i4_part_mode_a += 1;
                    }
                    if(0 <= ps_motion_pred[0].i1_ref_frame[1])
                    {
                        i4_part_mode_a += 2;
                    }

                    i4_temp = 3 * PRED_16x16;
                    i4_temp += (3 * (i4_part_mode_a - 1) - 1);
                    i4_temp = (i4_temp < 0) ? 0 : i4_temp;
                    i4_temp = g_au1_eb_mb_type[i4_temp];
                    ps_mb_params->u1_mb_type = i4_temp;
                    ps_part->u1_pred_mode = g_au1_mb_pred_mode[0][5 + i4_temp];
                }
            }
            else
            {
                /* motion prediction flag cases replicate the motion vectors for entire MB */
                isvcd_store_motion_map(ps_motion_pred, (ps_motion_pred), 0, i4_curr_mot_stride,
                                       NUM_MB_PARTS, NUM_MB_PARTS, SVCD_FALSE);

                isvcd_populate_ref_idx(ps_mb_params, ps_svc_mb_params, ps_motion_pred,
                                       ps_mb_part_info, i4_listx);
            }
            return i4_mb_mode;
        }
        /* ---------- reference layer MB is non 16x16 ------------------ */
        else
        {
            WORD32 ai4_sub_mb_mode[NUM_MB_PARTS] = {0};

            /* replicate the motion vectors for 8x8 */
            isvcd_store_motion_map(ps_motion_pred, ps_motion_pred, 0, i4_curr_mot_stride, 2, 2,
                                   SVCD_FALSE);

            if(2 == i4_listx)
            {
                WORD32 i4_indx = 0;

                /* replicate the motion vectors for 8x8 */
                /* check the 0th partiton reference indices */
                if(0 <= ps_motion_pred[0].i1_ref_frame[0])
                {
                    i4_indx += 1;
                }
                if(0 <= ps_motion_pred[0].i1_ref_frame[1])
                {
                    i4_indx += 2;
                }

                i4_indx = 3 * PRED_8x8 + (i4_indx - 1);
                ai4_sub_mb_mode[0] = g_au1_eb_submb_type[i4_indx];
            }

            /* derive the motion vectors and reference indices of 3 rem partitions */
            for(i4_blk_idx = 1; i4_blk_idx < NUM_MB_PARTS; i4_blk_idx++)
            {
                WORD32 i4_blk_y, i4_blk_x;
                mv_pred_t *ps_temp;

                i4_blk_x = i4_blk_idx & 1;
                i4_blk_y = i4_blk_idx >> 1;

                ps_temp = ps_motion_pred + (i4_blk_x << 1);
                ps_temp += (i4_blk_y * i4_curr_mot_stride << 1);

                /* store the reference layer positions */
                i4_part_idc = ((i4_ref_y + (i4_blk_y << 2)) << 16) + (i4_ref_x + (i4_blk_x << 2));
                isvcd_interlyr_motion_scale(pv_comp_mode_mv_ctxt, &i4_part_idc, ps_mb_params,
                                            ps_temp, i4_listx, (i4_mb_pic_x + (i4_blk_x << 2) + 1),
                                            (i4_mb_pic_y + (i4_blk_y << 2) + 1),
                                            ps_dec->ppv_map_ref_idx_to_poc);

                /* replicate the motion vectors for 8x8 */
                isvcd_store_motion_map(ps_temp, ps_temp, 0, i4_curr_mot_stride, 2, 2, SVCD_FALSE);

                if(2 == i4_listx)
                {
                    WORD32 i4_indx = 0;

                    /* check the 0th partiton reference indices */
                    if(0 <= ps_temp[0].i1_ref_frame[0])
                    {
                        i4_indx += 1;
                    }
                    if(0 <= ps_temp[0].i1_ref_frame[1])
                    {
                        i4_indx += 2;
                    }

                    i4_indx = 3 * PRED_8x8 + (i4_indx - 1);

                    ai4_sub_mb_mode[i4_blk_idx] = g_au1_eb_submb_type[i4_indx];
                }
            }

            /* if MB mode has to derivied */
            if(1 == u1_base_mode_flag)
            {
                WORD32 i4_horz_match, i4_vert_match;
                WORD32 i4_part_size = PRED_8x8;

                mv_pred_t *ps_motion_1;
                mv_pred_t *ps_motion_2;
                mv_pred_t *ps_motion_3;

                ps_motion_1 = ps_motion_pred + 2;
                ps_motion_2 = ps_motion_pred + (i4_curr_mot_stride << 1);
                ps_motion_3 = ps_motion_2 + 2;

                /* check if the motion in horz direction are same*/
                i4_horz_match = isvcd_check_motion(ps_motion_pred, ps_motion_1, i4_listx);
                i4_horz_match += isvcd_check_motion(ps_motion_2, ps_motion_3, i4_listx);

                /* check if the motion in vertical direction is same */
                i4_vert_match = isvcd_check_motion(ps_motion_pred, ps_motion_2, i4_listx);
                i4_vert_match += isvcd_check_motion(ps_motion_1, ps_motion_3, i4_listx);

                ps_mb_part_info->u1_num_part = 4;

                /* decide the partition size based on the results of matching */
                if((2 == i4_horz_match) && (2 == i4_vert_match))
                {
                    ps_mb_params->u1_mb_type = P_L0_16x16;
                    i4_part_size = PRED_16x16;
                    ps_mb_part_info->u1_num_part = 1;
                    *pu1_col_info++ = (PRED_16x16 << 6);

                    ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred->i1_ref_frame[0];
                    if(2 == i4_listx)
                        ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred->i1_ref_frame[1];

                    ps_part->u1_partwidth = 4;  // interms of 4x4
                    ps_part->u1_partheight = 4;
                    ps_part->u1_pred_mode = PRED_L0;
                    ps_part->u1_is_direct = 0;
                    ps_part->u1_sub_mb_num = 0;
                }
                else if(2 == i4_horz_match)
                {
                    ps_mb_params->u1_mb_type = P_L0_L0_16x8;
                    i4_part_size = PRED_16x8;
                    ps_mb_part_info->u1_num_part = 2;
                    *pu1_col_info++ = (PRED_16x8 << 6);
                    *pu1_col_info++ = (PRED_16x8 << 6);

                    ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred->i1_ref_frame[0];
                    ps_mb_part_info->i1_ref_idx[0][1] = ps_motion_pred[8].i1_ref_frame[0];
                    if(2 == i4_listx)
                    {
                        ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred->i1_ref_frame[1];
                        ps_mb_part_info->i1_ref_idx[1][1] = ps_motion_pred[8].i1_ref_frame[1];
                    }
                    ps_part->u1_partwidth = 4;  // interms of 4x4
                    ps_part->u1_partheight = 2;
                    ps_part->u1_pred_mode = PRED_L0;
                    ps_part->u1_is_direct = 0;
                    ps_part->u1_sub_mb_num = 0;

                    ps_part++;
                    ps_part->u1_partwidth = 4;
                    ps_part->u1_partheight = 2;
                    ps_part->u1_pred_mode = PRED_L0;
                    ps_part->u1_is_direct = 0;
                    ps_part->u1_sub_mb_num = 8;
                }
                else if(2 == i4_vert_match)
                {
                    ps_mb_params->u1_mb_type = P_L0_L0_8x16;
                    i4_part_size = PRED_8x16;
                    ps_mb_part_info->u1_num_part = 2;
                    *pu1_col_info++ = (PRED_8x16 << 6);
                    *pu1_col_info++ = (PRED_8x16 << 6);

                    ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred->i1_ref_frame[0];
                    ps_mb_part_info->i1_ref_idx[0][1] = ps_motion_pred[2].i1_ref_frame[0];
                    if(2 == i4_listx)
                    {
                        ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred->i1_ref_frame[1];
                        ps_mb_part_info->i1_ref_idx[1][1] = ps_motion_pred[2].i1_ref_frame[1];
                    }
                    ps_part->u1_partwidth = 2;  // interms of 4x4
                    ps_part->u1_partheight = 4;
                    ps_part->u1_pred_mode = PRED_L0;
                    ps_part->u1_is_direct = 0;
                    ps_part->u1_sub_mb_num = 0;

                    ps_part++;
                    ps_part->u1_partwidth = 2;
                    ps_part->u1_partheight = 4;
                    ps_part->u1_pred_mode = PRED_L0;
                    ps_part->u1_is_direct = 0;
                    ps_part->u1_sub_mb_num = 2;
                }

                /* store the part size to the mb params */
                ps_mb_params->u1_mb_mc_mode = i4_part_size;

                /* store the sub partition size */
                if(PRED_8x8 == i4_part_size)
                {
                    UWORD8 u1_ctr;
                    /* for P_MB sub part type is P_L0_8x8*/

                    ps_mb_params->u1_mb_type = P_8x8;
                    ps_mb_part_info->i1_ref_idx[0][0] = ps_motion_pred[0].i1_ref_frame[0];
                    ps_mb_part_info->i1_ref_idx[0][1] = ps_motion_pred[2].i1_ref_frame[0];
                    ps_mb_part_info->i1_ref_idx[0][2] = ps_motion_pred[8].i1_ref_frame[0];
                    ps_mb_part_info->i1_ref_idx[0][3] = ps_motion_pred[10].i1_ref_frame[0];
                    if(2 == i4_listx)
                    {
                        ps_mb_part_info->i1_ref_idx[1][0] = ps_motion_pred[0].i1_ref_frame[1];
                        ps_mb_part_info->i1_ref_idx[1][1] = ps_motion_pred[2].i1_ref_frame[1];
                        ps_mb_part_info->i1_ref_idx[1][2] = ps_motion_pred[8].i1_ref_frame[1];
                        ps_mb_part_info->i1_ref_idx[1][3] = ps_motion_pred[10].i1_ref_frame[1];
                    }

                    for(u1_ctr = 0; u1_ctr < 4; u1_ctr++)
                    {
                        *pu1_col_info++ = (PRED_8x8 << 6);

                        ps_part->u1_partwidth = 2;  // interms of 4x4
                        ps_part->u1_partheight = 2;
                        ps_part->u1_pred_mode = PRED_L0;
                        ps_part->u1_is_direct = 0;
                        ps_part->u1_sub_mb_num = (u1_ctr & 0x01) * 2 + (u1_ctr >> 1) * 8;
                        ps_part++;
                    }
                }

                if(2 == i4_listx)
                {
                    ps_part = (parse_part_params_t *) pv_part;
                    pu1_col_info = ps_mb_part_info->u1_col_info;
                    isvcd_interlyr_mbmode_pred_bmb(ps_ctxt, ps_motion_pred, i4_curr_mot_stride,
                                                   i4_part_size, &ai4_sub_mb_mode[0], ps_mb_params,
                                                   ps_part, pu1_col_info);
                }
            } /* end of mode derivation */
            else
            {
                isvcd_populate_ref_idx(ps_mb_params, ps_svc_mb_params, ps_motion_pred,
                                       ps_mb_part_info, i4_listx);

            } /* non 16x16 mv mode derivation */
        }
    }
    return i4_mb_mode;
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_compute_scaled_offsets                              */
/*                                                                           */
/*  Description   : this module does the projection of the current layer     */
/*                   points (x,0) and (0,y) on to the reference layer and    */
/*                   gets the 1/16 sample of the reference location          */
/*                   x ranges from 0 - frame width                           */
/*                   y ranges from 0 - frame height                          */
/*                   this projection is done for LUMA only                   */
/*  Inputs        :  ps_curr_lyr_slice_prms: pointer to current layer slice  */
/*                                           parameters                      */
/*                   ps_ref_lyr_slice_prms: pointer to ref layer slice prms  */
/*                   pi2_offset_x         : pointer to store x projected     */
/*                   pi2_offset_y         : pointer to store y projected     */
/*  Globals       :  none                                                    */
/*  Processing    :  it store the projected values for those points in the   */
/*                   crop window                                             */
/*  Outputs       :  projected locations                                     */
/*  Returns       :  none                                                    */
/*                                                                           */
/*  Issues        : assumes that outside crop window no projection           */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_compute_scaled_offsets(res_prms_t *ps_curr_res_prms, res_prms_t *ps_ref_res_prms,
                                    WORD16 *pi2_offset_x, WORD16 *pi2_offset_y, UWORD8 u1_level_idc)
{
    WORD32 i4_offset_x, i4_offset_y;
    UWORD32 i4_scaled_ref_lyr_width;
    UWORD32 i4_scaled_ref_lyr_height;
    UWORD32 i4_ref_lyr_width;
    UWORD32 i4_ref_lyr_height;
    UWORD32 i4_shift_x, i4_shift_y;
    UWORD32 i4_scale_x, i4_scale_y;
    WORD32 i4_cntr;
    WORD32 i4_scale_add_x, i4_scale_add_y;
    WORD32 i4_curr_lyr_width, i4_curr_lyr_height;

    if((NULL == ps_curr_res_prms) || (NULL == ps_ref_res_prms) || (NULL == pi2_offset_x) ||
       (NULL == pi2_offset_y))
    {
        return NOT_OK;
    }
    /* initial calculation */
    i4_offset_x = ps_curr_res_prms->s_ref_lyr_scaled_offset.i2_left;
    i4_offset_y = ps_curr_res_prms->s_ref_lyr_scaled_offset.i2_top;

    /* get the width and height */
    i4_scaled_ref_lyr_width = ps_curr_res_prms->u2_scaled_ref_width;
    i4_scaled_ref_lyr_height = ps_curr_res_prms->u2_scaled_ref_height;
    i4_ref_lyr_width = ps_ref_res_prms->i4_res_width;
    i4_ref_lyr_height = ps_ref_res_prms->i4_res_height;
    i4_curr_lyr_width = ps_curr_res_prms->i4_res_width;
    i4_curr_lyr_height = ps_curr_res_prms->i4_res_height;

    /* derive shift x and y based on level idd */
    if(u1_level_idc <= 30)
    {
        i4_shift_x = 16;
        i4_shift_y = 16;
    }
    else
    {
        i4_shift_x = 31 - isvcd_get_ceil_log2(i4_ref_lyr_width);
        i4_shift_y = 31 - isvcd_get_ceil_log2(i4_ref_lyr_height);
    }

    /* assert on max ranges of width and shift values */
    if((i4_ref_lyr_width > H264_MAX_FRAME_WIDTH) ||
       (i4_scaled_ref_lyr_width > H264_MAX_FRAME_WIDTH) ||
       (i4_ref_lyr_height > H264_MAX_FRAME_HEIGHT) ||
       (i4_scaled_ref_lyr_height > H264_MAX_FRAME_HEIGHT) ||
       (i4_curr_lyr_width > H264_MAX_FRAME_WIDTH) || (i4_curr_lyr_height > H264_MAX_FRAME_HEIGHT))
    {
        return NOT_OK;
    }

    /* calculate scale factor x and y */
    i4_scale_x = (((UWORD32) i4_ref_lyr_width << i4_shift_x) + (i4_scaled_ref_lyr_width >> 1)) /
                 i4_scaled_ref_lyr_width;

    i4_scale_y = (((UWORD32) i4_ref_lyr_height << i4_shift_y) + (i4_scaled_ref_lyr_height >> 1)) /
                 i4_scaled_ref_lyr_height;

    /* calcualte the values to be added based on left and top offset */
    i4_scale_add_x = (1 << (i4_shift_x - 1)) - i4_offset_x * i4_scale_x;
    i4_scale_add_y = (1 << (i4_shift_y - 1)) - i4_offset_y * i4_scale_y;

    /* derive the projected locations in the reference layer */
    for(i4_cntr = 0; i4_cntr < i4_curr_lyr_width; i4_cntr++)
    {
        WORD32 i4_ref_x;
        i4_ref_x = (i4_cntr * i4_scale_x + i4_scale_add_x) >> i4_shift_x;
        *pi2_offset_x++ = (WORD16) i4_ref_x;
    }

    /* derive the projected locations in the reference layer */
    for(i4_cntr = 0; i4_cntr < i4_curr_lyr_height; i4_cntr++)
    {
        WORD32 i4_ref_y;
        i4_ref_y = (i4_cntr * i4_scale_y + i4_scale_add_y) >> i4_shift_y;
        *pi2_offset_y++ = (WORD16) i4_ref_y;
    }
    return OK;
}

/*****************************************************************************/
/*                                                                           */
/*  Function Name : isvcd_comp_mode_mv_res_init                               */
/*                                                                           */
/*  Description   : this function calculates the scale factors and initialise*/
/*                  the context structure                                    */
/*                                                                           */
/*  Inputs        : pv_comp_mode_mv_ctxt: handle to private structure        */
/*                  ps_curr_lyr_res_prms: pointer to current resolution      */
/*                                               params                      */
/*                  pi2_ref_loc_x             : pointer to buffer having the */
/*                                              projected locations horz     */
/*                  pi2_ref_loc_y             : pointer to buffer having the */
/*                                              projected location vertical  */
/*  Globals       : none                                                     */
/*  Processing    : it calculates the scale factors and stores it            */
/*                                                                           */
/*  Outputs       : none                                                     */
/*  Returns       : none                                                     */
/*                                                                           */
/*  Issues        : none                                                     */
/*                                                                           */
/*  Revision History:                                                        */
/*                                                                           */
/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
/*         06 09 2021   vijayakumar          creation                        */
/*                                                                           */
/*****************************************************************************/
WORD32 isvcd_comp_mode_mv_res_init(void *pv_svc_dec)
{
    /*! Flow of the module is as follows                                   */
    /*! 1. calculates the scale factors for dyadic cases                   */
    /*! 2. calculaets the loop counts and part width and height based on
           dyadic scale factor                                             */
    /*! 2. calculate the MV scale factors                                  */
    /*! 3. initialises the default mv ped structure with deafult values    */

    mode_motion_ctxt_t *ps_ctxt;
    mode_motion_lyr_ctxt *ps_lyr_mem;
    dec_seq_params_t *ps_sps;
    svc_dec_lyr_struct_t *ps_svc_lyr_dec = (svc_dec_lyr_struct_t *) pv_svc_dec;
    dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
    svc_dec_lyr_struct_t *ps_svc_dec_ref_layer;
    WORD32 ret;
    WORD32 i4_scaled_ref_lyr_width;
    WORD32 i4_scaled_ref_lyr_height;
    WORD32 i4_ref_lyr_width;
    WORD32 i4_ref_lyr_height;
    res_prms_t *ps_curr_lyr_res_prms = &ps_svc_lyr_dec->s_res_prms;

    ps_svc_dec_ref_layer = ps_svc_lyr_dec->ps_dec_svc_ref_layer;
    if(NULL == ps_curr_lyr_res_prms)
    {
        return NOT_OK;
    }

    ps_ctxt = (mode_motion_ctxt_t *) ps_svc_lyr_dec->pv_mode_mv_sample_ctxt;
    ps_ctxt->u1_direct_8x8_inference_flag = ps_curr_lyr_res_prms->u1_direct_8x8_inference_flag;

    /* if called for base resolution store deafult values */
    if(SVCD_TRUE == ps_svc_lyr_dec->u1_base_res_flag)
    {
        ps_ctxt->i4_res_id = -1;
        ps_ctxt->i4_ref_width = ps_curr_lyr_res_prms->i4_res_width;
        ps_ctxt->i4_ref_height = ps_curr_lyr_res_prms->i4_res_height;
        return OK;
    }

    /* call the function which populates the projected ref locations */
    ps_sps = ps_dec->ps_cur_sps;

    /* store the res id appropriately */
    ps_ctxt->i4_res_id = ps_svc_lyr_dec->u1_layer_id - 1;

    /* get the current layer ctxt */
    ps_lyr_mem = &ps_ctxt->as_res_lyr_mem[ps_ctxt->i4_res_id];

    /* store the current and reference res params to the context */
    ps_lyr_mem->ps_curr_lyr_res_prms = ps_curr_lyr_res_prms;

    /* store the reference layer mv bank pointer */
    ps_lyr_mem->pv_ref_mv_bank_l0 = ps_svc_dec_ref_layer->s_dec.s_cur_pic.ps_mv;

    /* store the reference layer mb mode pointer */
    ps_lyr_mem->s_ref_mb_mode.pv_buffer = ps_svc_dec_ref_layer->ps_inter_lyr_mb_prms_frm_start;
    ps_lyr_mem->s_ref_mb_mode.i4_num_element_stride =
        ps_svc_dec_ref_layer->u2_inter_lyr_mb_prms_stride;
    ps_lyr_mem->s_ref_mb_mode.i4_element_size = sizeof(inter_lyr_mb_prms_t);

    /* check for recomputation of mapping required */
    if(SVCD_TRUE == ps_curr_lyr_res_prms->u1_remap_req_flag)
    {
        res_prms_t s_ref_res_prms = {0};

        /* store the reference layer resolution width and height */
        s_ref_res_prms.i4_res_width = ps_ctxt->i4_ref_width;
        s_ref_res_prms.i4_res_height = ps_ctxt->i4_ref_height;

        /* call projection map calculation function */
        ret = isvcd_compute_scaled_offsets(ps_curr_lyr_res_prms, &s_ref_res_prms,
                                           ps_lyr_mem->pi2_ref_loc_x, ps_lyr_mem->pi2_ref_loc_y,
                                           ps_sps->u1_level_idc);
        if(OK != ret)
        {
            return NOT_OK;
        }

        /* derive the scaling variables */
        ps_lyr_mem->i4_offset_x = ps_curr_lyr_res_prms->s_ref_lyr_scaled_offset.i2_left;

        ps_lyr_mem->i4_offset_y = ps_curr_lyr_res_prms->s_ref_lyr_scaled_offset.i2_top;

        /* get the width and heights */
        i4_scaled_ref_lyr_width = ps_curr_lyr_res_prms->u2_scaled_ref_width;
        i4_scaled_ref_lyr_height = ps_curr_lyr_res_prms->u2_scaled_ref_height;
        i4_ref_lyr_width = ps_ctxt->i4_ref_width;
        i4_ref_lyr_height = ps_ctxt->i4_ref_height;

        /*store the reference layer width adn height */
        ps_lyr_mem->i4_ref_width = ps_ctxt->i4_ref_width;
        ps_lyr_mem->i4_ref_height = ps_ctxt->i4_ref_height;

        if((i4_ref_lyr_width > H264_MAX_FRAME_WIDTH) || (i4_ref_lyr_width <= 0)) return NOT_OK;
        if((i4_scaled_ref_lyr_width > H264_MAX_FRAME_WIDTH) || (i4_scaled_ref_lyr_width <= 0))
            return NOT_OK;
        if((i4_ref_lyr_height > H264_MAX_FRAME_HEIGHT) || (i4_ref_lyr_height <= 0)) return NOT_OK;
        if((i4_scaled_ref_lyr_height > H264_MAX_FRAME_HEIGHT) || (i4_scaled_ref_lyr_height <= 0))
            return NOT_OK;

        /* derivation of variables for dyadic cases cropping should be MB aligned */
        /* default values for flags */
        ps_lyr_mem->pf_inter_lyr_pred = &isvcd_compute_interlyr_motion_mode;

        if(SVCD_TRUE == ps_curr_lyr_res_prms->u1_dyadic_flag)
        {
            ps_lyr_mem->pf_inter_lyr_pred = &isvcd_interlyr_motion_mode_pred_dyadic;
        }

        /* Store the Dyadic flag */
        ps_lyr_mem->i4_dyadic_flag = ps_curr_lyr_res_prms->u1_dyadic_flag;

        /* derive the scaling factors for motion upscaling */
        /* this is derived assuming no crop change flag is present */
        ps_lyr_mem->i4_scale_mv_x =
            ((i4_scaled_ref_lyr_width << 16) + (i4_ref_lyr_width >> 1)) / i4_ref_lyr_width;

        ps_lyr_mem->i4_scale_mv_y =
            ((i4_scaled_ref_lyr_height << 16) + (i4_ref_lyr_height >> 1)) / i4_ref_lyr_height;
    }
    else
    {
        /* should take false value */
        if(SVCD_FALSE != ps_curr_lyr_res_prms->u1_remap_req_flag)
        {
            return NOT_OK;
        }
    }

    /* store the current layer width and height to context */
    ps_ctxt->i4_ref_width = ps_curr_lyr_res_prms->i4_res_width;
    ps_ctxt->i4_ref_height = ps_curr_lyr_res_prms->i4_res_height;

    return OK;
}
